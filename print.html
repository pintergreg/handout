<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jegyzet</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Szoftverfejlesztés multinacionális vállalatoknál">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="description.html"><strong aria-hidden="true">1.</strong> Tárgyleírás</a></li><li class="chapter-item expanded "><a href="schedule.html"><strong aria-hidden="true">2.</strong> Ütemezés</a></li><li class="chapter-item expanded "><a href="literature.html"><strong aria-hidden="true">3.</strong> Felkészülést segítő anyagok</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lectures/agile_scrum_kanban.html"><strong aria-hidden="true">3.1.</strong> Agile, SCRUM, Kanban</a></li><li class="chapter-item "><a href="lectures/daily_work.html"><strong aria-hidden="true">3.2.</strong> Daily Work, Clean Code, Version Control</a></li><li class="chapter-item "><a href="lectures/tdd.html"><strong aria-hidden="true">3.3.</strong> TDD, Unit Testing</a></li><li class="chapter-item "><a href="lectures/legacy_code.html"><strong aria-hidden="true">3.4.</strong> Legacy Code, SOLID</a></li><li class="chapter-item "><a href="lectures/review.html"><strong aria-hidden="true">3.5.</strong> Review</a></li><li class="chapter-item "><a href="lectures/ci.html"><strong aria-hidden="true">3.6.</strong> Continuous Integration</a></li><li class="chapter-item "><a href="lectures/software_architecture.html"><strong aria-hidden="true">3.7.</strong> Software Architecture</a></li><li class="chapter-item "><a href="mindmap.html"><strong aria-hidden="true">3.8.</strong> MindMap</a></li></ol></li><li class="chapter-item expanded "><a href="software.html"><strong aria-hidden="true">4.</strong> A feladat</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints.html"><strong aria-hidden="true">4.1.</strong> Sprintek</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprint_1.html"><strong aria-hidden="true">4.1.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprint_2.html"><strong aria-hidden="true">4.1.2.</strong> Sprint 2</a></li><li class="chapter-item "><a href="sprint_3.html"><strong aria-hidden="true">4.1.3.</strong> Sprint 3</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="working_environment.html"><strong aria-hidden="true">5.</strong> Munkakörnyezet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">5.1.</strong> Git</a></li><li class="chapter-item "><a href="github.html"><strong aria-hidden="true">5.2.</strong> GitHub</a></li><li class="chapter-item "><a href="developing_tools.html"><strong aria-hidden="true">5.3.</strong> Fejlesztői eszközök</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="vs_code.html"><strong aria-hidden="true">5.3.1.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="intellij_rider.html"><strong aria-hidden="true">5.3.2.</strong> IntelliJ Rider</a></li><li class="chapter-item "><a href="intellij_idea.html"><strong aria-hidden="true">5.3.3.</strong> IntelliJ IDEA (Java)</a></li><li class="chapter-item "><a href="code_formatting.html"><strong aria-hidden="true">5.3.4.</strong> Kódformázás</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="csharp_style_guide.html"><strong aria-hidden="true">5.3.4.1.</strong> C#</a></li><li class="chapter-item "><a href="java_style_guide.html"><strong aria-hidden="true">5.3.4.2.</strong> Java</a></li></ol></li></ol></li><li class="chapter-item "><a href="workflow.html"><strong aria-hidden="true">5.4.</strong> Munkafolyamat</a></li></ol></li><li class="chapter-item expanded "><a href="implementation.html"><strong aria-hidden="true">6.</strong> Implementáció</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="virtual_world.html"><strong aria-hidden="true">6.1.</strong> Virtuális világ</a></li><li class="chapter-item "><a href="physics.html"><strong aria-hidden="true">6.2.</strong> Fizika</a></li><li class="chapter-item "><a href="sensors.html"><strong aria-hidden="true">6.3.</strong> Szenzorok</a></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">6.4.</strong> Vezetéstámogató funkciók</a></li><li class="chapter-item "><a href="reference_architecture.html"><strong aria-hidden="true">6.5.</strong> Referencia architektúra</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Jegyzet</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#szoftverfejlesztés-multinacionális-vállalatoknál" id="szoftverfejlesztés-multinacionális-vállalatoknál">Szoftverfejlesztés multinacionális vállalatoknál</a></h1>
<p>A tárgy keretében a hallgatók lehetőséget kapnak megtapasztalni egy multinacionális környezetben történő szoftverfejlesztés mikéntjét és kihívásait. A félév során a hallgatók egy, vezetéstámogató rendszerek működésének demonstrációjára szolgáló játék fejlesztésén keresztül  megismerhetik a  Scrum Agile metodológiát, kipróbálhatják a Test Driven Developmentet, elsajátíthatják a Clean Code írásának alapelveit, tapasztalatot szerezhetnek a jó Code Review végzésében, továbbá elméleti ismeretet szereznek a Software Craftsmanshipről, Agile-ról általában, a Continuous Integration-ről.</p>
<p>A tárgy kettős felépítésű - minden alkalommal elméleti előadáson mutat be egy új ismeretanyagot, amit aztán a hallgatók a gyakorlatba ültethetnek a saját csapatukon belül. A félév során kis létszámú (4-7 fős) csapatokra bontva három sprintet kell teljesíteni, minden sprintben működő szoftvert szállítani, amit a hallgatók terveznek, implementálnak (Java nyelven, Git és IntelliJ IDEA segítségével), integrálnak és verifikálnak majd csapatonként mutatják be saját kontribúciójukat. Ez teljes féléves órán kívüli elköteleződést és felelősség vállalást kíván a csapat sikere iránt - az értékelés jelentős részét a gyakorlati munka adja.</p>
<p>A tantárgy célja, hogy a hallgatók olyan tapasztalatot szerezzenek, amely egy tipikus multinacionális környezetben előfordul: párhuzamos és komponens alapú szoftverfejlesztés, megrendelő fókusz, határidős fejlesztések, proaktivitás, kommunikációs és (ön)szervező készség, függőségek és blokkoló tényezők feloldása, megoldása.</p>
<h1><a class="header" href="#mottó" id="mottó">Mottó</a></h1>
<blockquote>
<p>A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away.</p>
<p><a href="https://en.wikiquote.org/wiki/Antoine_de_Saint_Exup%C3%A9ry">Antoine de Saint-Exupéry</a></p>
</blockquote>
<h1><a class="header" href="#Ütemezés" id="Ütemezés">Ütemezés</a></h1>
<p>Az órák csütörtökönként a BA.F.07-ben vannak (<a href="https://teams.microsoft.com/l/team/19%3ac7cf754b3c92495bb1799aa81597d88a%40thread.tacv2/conversations?groupId=a56552c3-1b48-44d8-af21-7ac594aa9009&amp;tenantId=1d6a56fa-705a-4bbc-8004-67a21d5e9b97">online, MS Teams-en</a>), neptun szerint 08:00-10:35 között előadás és 10:45-11:30 között gyakorlat. (Ezek aránya valamint közte a szünet az aktuális előadásanyag és az igények szerint módosulhat). A „gyakorlat” nem labor, hanem sokkal inkább konzultáció!</p>
<table><thead><tr><th align="right">hét</th><th align="center">dátum</th><th align="center">előadás</th><th align="center">gyakorlat</th></tr></thead><tbody>
<tr><td align="right">1.</td><td align="center">09. 10.</td><td align="center">Bevezető, áttekintés, <a href="https://www.lhpes.com/blog/what-is-aspice-in-automotive">aSpice alapok</a></td><td align="center">csapatsorsolás, <a href="sprint_1.html">első feladat kiadás</a>, Sprint Planning, Task Definition Workshop, Team commitment, Scheduling</td></tr>
<tr><td align="right">2.</td><td align="center">09. 17.</td><td align="center"><a href="lectures/agile_scrum_kanban.html">Agile, SCRUM, Kanban</a></td><td align="center">git, GitHub, IDEA ismertetés</td></tr>
<tr><td align="right">3.</td><td align="center">09. 24.</td><td align="center"><a href="lectures/daily_work.html">Napi munka, verziókezelők</a></td><td align="center">Branch review, status review, standup (did, will, blocking)</td></tr>
<tr><td align="right">4.</td><td align="center">10. 01.</td><td align="center"><a href="lectures/tdd.html">TDD, Unit Testing</a></td><td align="center">TDD kata</td></tr>
<tr><td align="right">5.</td><td align="center"><strong>10. 08.</strong></td><td align="center"><strong>első demo</strong>, retrospektív</td><td align="center"><a href="sprint_2.html">második feladat kiadás</a>, Sprint planning, Task Definition Workshop, Team commitment, Scheduling</td></tr>
<tr><td align="right">6.</td><td align="center">10. 15.</td><td align="center"><a href="lectures/legacy_code.html">Legacy Code, SOLID</a></td><td align="center">Refactoring gyakorlat egy előre előkészített példán</td></tr>
<tr><td align="right">7.</td><td align="center">10. 22.</td><td align="center"><a href="lectures/review.html">Review</a></td><td align="center">Random code review egy tetszőleges elfogadott pull requestből</td></tr>
<tr><td align="right">8.</td><td align="center">10. 29.</td><td align="center"><a href="lectures/ci.html">Continous Integration</a></td><td align="center">Set up a CI script running all implemented unit tests</td></tr>
<tr><td align="right">9.</td><td align="center"><strong>11. 05.</strong></td><td align="center"><strong>második demo</strong>, retrospektív</td><td align="center"><a href="sprint_3.html">harmadik feladat kiadás</a>, Sprint planning, Task Definition Workshop, Team commitment, Scheduling</td></tr>
<tr><td align="right">10.</td><td align="center">11. 12.</td><td align="center">Software Architecture</td><td align="center"></td></tr>
<tr><td align="right">11.</td><td align="center">11. 19.</td><td align="center">Konzultáció</td><td align="center"></td></tr>
<tr><td align="right">12.</td><td align="center">11. 26.</td><td align="center">Összefoglalás, konzultáció</td><td align="center"></td></tr>
<tr><td align="right">13.</td><td align="center"><strong>12. 03.</strong></td><td align="center"><strong>harmadik demo</strong>, retrospektív, tárgy feedback</td><td align="center">Pair programming, Coding Dojo</td></tr>
<tr><td align="right">14.</td><td align="center"><strong>12. 10.</strong></td><td align="center"><strong>Zárthelyi dolgozat</strong> 08:00-tól 09:30-ig (90 perc), 1.?? és 1.?? laborok</td><td align="center"></td></tr>
</tbody></table>
<h2><a class="header" href="#gantt-diagram" id="gantt-diagram">Gantt diagram</a></h2>
<div class="mermaid">
    gantt
    dateFormat  YYYY-MM-DD
    axisFormat  %m-%d
    title 2020/21 tanév I.félév
    section Sprint 1
        Sprint 1 :active, sprint1, 2020-09-10, 4w
    section Sprint 2
        Sprint 2 :active, sprint2, after sprint1, 4w
    section Sprint 3
        Sprint 3 :active, sprint3, after sprint2, 4w
    click sprint1 href "./sprint_1.html"
    click sprint2 href "./sprint_2.html"
    click sprint3 href "./sprint_3.html"
</div>
<!--
# Házi feladat - 1. hét

1. GitHub fiók létrehozása
    * ha még nincs
2. 11 JDK telepítése, mivel a szoftvert Java nyelven kell elkészíteni
    * ha nincs fönt
3. Fejlesztőkörnyezet telepítése és beállítása
    * IntelliJ IDEA az ajánlott és támogatott eszköz
4. Git és GitHub oktatóanyagok elolvasása
    * ha vannak hiányosságok
    * az órán nincs idő szájbarágósan git használatot oktatni, erre vannak interaktív oktatófelületek
    * ez mindenkinek egyéni felelőssége, ám ha konkrét kérdések merülnek fel, akkor ezekre természetesen kitérünk
5. Git repó klónozása
6. Kód futtatása a futtató- és a fejlesztőkörnyezet beállításainak tesztelése céljából
7. A jegyzet és az abban taglalt segédanyagok megismerése
8. Az elkészítendő szoftver átgondolása (lásd readme), statikus és dinamikus modell elkészítése komponens szinten
    * Ennek terjedelme (az órái példa alapján): egy absztrakciós szint a négyfelé bontás (kb. user story szint), és egy az ez alatti egyel, minden komponens még egy kibontása, kb. egyenrangú komponensek létrehozására - osztály szintre nem mennék le, még ha a végén ezekből akár osztály is lesz. Szóval kettő struktúra, kettő dinamikus viselkedést leíró diagram, egy magasabb és egy alacsonyabb absztrakciós szinten. Hogy konkrétan hány building block, azt mindenkinek "érzésre" kell megállapítania, ezért szubjektív az architektúra.
    * Ez egy egyéni feladat, hiszen még nincsenek csapatok. Az elkészítéshez javasolt eszközök: MS Visio, https://www.draw.io/.
    * Az elkészült diagramoknak a következő órán bemutatható állapotban kell lenniük.
-->
<h1><a class="header" href="#demók" id="demók">Demók</a></h1>
<p>A félév során a csapatok három alkalommal prezentálják az elvégzett munkát. A „demók” az <em>elkészült</em> szoftver megrendelőnek való bemutatását szimulálják. Nem a kódra vagyunk kíváncsiak, hanem működés közben szeretnénk látni, hogy a szoftver teljesíti feladatban foglalt követelményeket.
A bemutatás során, a <code>master</code> branchre befogadott kódot vesszük figyelembe, minden egyéb <em>„nem készült el határidőre”</em>, azaz értékelhetetlen.</p>
<h1><a class="header" href="#zárthelyi" id="zárthelyi">Zárthelyi</a></h1>
<p>Ismert, Moodle-ös teszt, 50 kérdéssel, erre 90 perc áll majd a rendelkezésre. Minden kérdéshez 4 válaszlehetőség, amelyek közül pontosan egy a helyes. (Vannak „az alábbiak közül melyik NEM helyes” felépítésű kérdések is.) A rendelkezésre álló idő alatt kérdéseket tetszőleges alkalommal felül lehet vizsgálni, módosítani a teszt „lezárása” után azonnal kiértékelésre is kerül.</p>
<h1><a class="header" href="#felkészülést-segítő-anyagaok" id="felkészülést-segítő-anyagaok">Felkészülést segítő anyagaok</a></h1>
<h2><a class="header" href="#ajánlott-irodalom" id="ajánlott-irodalom">Ajánlott irodalom</a></h2>
<ol>
<li>The Software Craftsman: Professionalism, Pragmatism, Pride – Robert C. Martin</li>
<li>The Clean Coder: A Code of Conduct for Professional Programmers – Robert C. Martin</li>
<li>Clean Code: A Handbook of Agile Software Craftsmanship – Robert C. Martin</li>
<li>Working Effectively with Legacy Code - Michael Feathers</li>
<li>TDD by Example – Kent Beck</li>
<li>XP Explained – Kent Beck</li>
</ol>
<h2><a class="header" href="#online-anyagok-fejezetenként" id="online-anyagok-fejezetenként">Online anyagok fejezetenként</a></h2>
<ul>
<li><a href="./lectures/agile_scrum_kanban.html">Agile, SCRUM, Kanban</a></li>
<li><a href="./lectures/daily_work.html">Daily Work, Clean Code, Version Control</a></li>
<li><a href="./lectures/tdd.html">TDD, Unit Testing</a></li>
<li><a href="./lectures/legacy_code.html">Legacy Code, SOLID</a></li>
<li><a href="./lectures/review.html">Review</a></li>
<li><a href="./lectures/ci.html">Continuous Integration</a></li>
<li><a href="./lectures/software_architecture.html">Software Architecture</a></li>
</ul>
<h2><a class="header" href="#javasolt-felkészülési-módszer" id="javasolt-felkészülési-módszer">Javasolt (fel)készülési módszer</a></h2>
<p>Mivel a diákat nem adjuk ki, célszerű jegyzetelni: <strong>címszavakat</strong>, <strong>fogalmakat</strong> leírni, gondolatmenetet rögzíteni (bár ehhez is kaptok kész anyagot az alábbi mindmap tekintetében). Nem a diát kell lekörmölni (annak ellenére sem, hogy azokat nem kaphatjátok meg), annak nincs értelme! Óra után (az óra hetében), ezekre rákeresni (pl. Google), valamint elolvasni az itteni anyagokat. A hivatkozott linkek mögötti tartalom olyan anyagmennyiséget jelent, amelyet a ZH előtti estén nem lehet feldolgozni.</p>
<h2><a class="header" href="#mindmap" id="mindmap">Mindmap</a></h2>
<p>A témakörök „mindmap” formájú összefoglalása <a href="mm/szfmv.mm">letölthető itt</a>, megnyitáshoz a <a href="http://freemind.sourceforge.net/wiki/index.php/Main_Page">Freemind</a> nevű javás eszköz szükséges.
Vagy közvetlenül <a href="mm/szfmv.html">innen megnyitható</a> a HTML-re fordított változata.</p>
<h2><a class="header" href="#címszavak" id="címszavak">Címszavak</a></h2>
<p>Címszavak (különösebb sorrend nélkül) amelyek az elméleti anyagot több-kevésbé lefedik. Ha valakinek ezeket a fogalmakat nem tudja kifejteni (nem tiszta mit jelent), akkor célszerű megkérdezni a Googlet vagy a Wikit. ;)</p>
<p><a href="https://en.wikipedia.org/wiki/Agile_software_development" data-wiki-lang="en" data-wiki-title="Agile software development">agile</a>,
<a href="https://en.wikipedia.org/wiki/Agile_software_development#The_Agile_Manifesto">agile manifesto</a>,
<a href="https://en.wikipedia.org/wiki/Software_craftsmanship" data-wiki-lang="en" data-wiki-title="Software craftsmanship">software craftmanship</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)" data-wiki-lang="en" data-wiki-title="Scrum (software development)">SCRUM</a>,
<a href="https://en.wikipedia.org/wiki/User_story" data-wiki-lang="en" data-wiki-title="User story">user story</a>,
backlog (<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Product_backlog">product backlog</a> vs. <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_backlog">sprint backlog</a>; ki szerkeszti?),
task (hossza, elemei),
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint">sprint</a> (hossza),
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_review">sprint review</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_planning">sprint planning</a>,
<a href="https://en.wikipedia.org/wiki/Burn_down_chart" data-wiki-lang="en" data-wiki-title="Burn down chart">burndown chart</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Scrum_of_scrums">scrum of scrums</a>,
<a href="https://en.wikipedia.org/wiki/Business_value" data-wiki-lang="en" data-wiki-title="Business value">business value</a>,
story point,
<a href="https://en.wikipedia.org/wiki/Stand-up_meeting" data-wiki-lang="en" data-wiki-title="Stand-up meeting">standup</a> (hossza, mikor van, ki vesz rajta részt, 3 kérdés),
blocking issue,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Sprint_retrospective">retro(spective)</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Backlog_refinement">backlog refinement</a> (aka backlog grooming),
demo,
daily cycle,
clean code,
traceability (eszkaláció),
version control (elosztott vs. centralizált),
<a href="https://en.wikipedia.org/wiki/Code_refactoring" data-wiki-lang="en" data-wiki-title="Code refactoring">refactoring</a>,
review (informal, walkthrough, technical, inspection),
<a href="https://en.wikipedia.org/wiki/Pair_programming" data-wiki-lang="en" data-wiki-title="Pair programming">pair programming</a>,
scrum team tagjai: <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Scrum_master">scrum master</a>, <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Product_owner">product owner</a>, <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Development_team">development team</a>,
<a href="https://en.wikipedia.org/wiki/Cross-functional_team" data-wiki-lang="en" data-wiki-title="Cross-functional team">cross functional team</a>,
self-organizing team,
stakeholder,
<a href="https://en.wikipedia.org/wiki/Kanban_(development)" data-wiki-lang="en" data-wiki-title="Kanban (development)">kanban</a>,
scrumban,
<a href="https://en.wikipedia.org/wiki/Waterfall_model" data-wiki-lang="en" data-wiki-title="Waterfall model">waterfall</a>,
<a href="https://en.wikipedia.org/wiki/V-Model_(software_development)" data-wiki-lang="en" data-wiki-title="V-Model (software development)">v-model</a>,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Scrum_of_scrums">scrum of scrums</a> (ambassador),
<a href="https://en.wikipedia.org/wiki/Test-driven_development" data-wiki-lang="en" data-wiki-title="Test-driven development">Test-driven development</a>,
(software) unit,
unit testing (arrange, act, assert, annihilate),
test suite,
test case,
quality assurance,
<a href="http://vinaikopp.com/2016/02/09/about_code_katas/">coding kata</a>,
<a href="https://en.wikipedia.org/wiki/Code_golf" data-wiki-lang="en" data-wiki-title="Code golf">code golf</a>,
legacy code,
<a href="https://en.wikipedia.org/wiki/Code_smell" data-wiki-lang="en" data-wiki-title="Code smell">code smell</a>,
rotting code,
dependency reduction,
seams,
<a href="https://en.wikipedia.org/wiki/Continuous_integration" data-wiki-lang="en" data-wiki-title="Continuous integration">Continuous integration</a>,
<a href="https://en.wikipedia.org/wiki/Test_automation" data-wiki-lang="en" data-wiki-title="Test automation">Test automation</a>,
<a href="https://en.wikipedia.org/wiki/Continuous_deployment" data-wiki-lang="en" data-wiki-title="Continuous deployment">Continuous deployment</a>,
minimized context switch,
<a href="https://en.wikipedia.org/wiki/DevOps" data-wiki-lang="en" data-wiki-title="DevOps">DevOps</a>,
coding dojo,
<a href="https://en.wikipedia.org/wiki/SOLID" data-wiki-lang="en" data-wiki-title="SOLID">SOLID priciples</a>,
clean code,
<a href="https://en.wikipedia.org/wiki/Scrum_(software_development)#Definition_of_done_(DoD)">definition of done</a>,
milestone,
deadline,
mocking (dummy, stub, spy, mock, fake),
requirement,
<a href="https://en.wikipedia.org/wiki/Requirements_engineering" data-wiki-lang="en" data-wiki-title="Requirements engineering">requirement engineering</a>,
centralized version control,
<a href="https://en.wikipedia.org/wiki/Distributed_version_control" data-wiki-lang="en" data-wiki-title="Distributed version control">distributed version control</a>,
traceability, finding, bug fixing, optimizing, feature envy,
<a href="https://en.wikipedia.org/wiki/KISS_principle" data-wiki-lang="en" data-wiki-title="KISS principle">KISS</a>,
<a href="https://en.wikipedia.org/wiki/Programming_complexity" data-wiki-lang="en" data-wiki-title="Programming complexity">code complexity</a>,
<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" data-wiki-lang="en" data-wiki-title="Cyclomatic complexity">cyclomatic complexity</a>,
<a href="https://en.wikipedia.org/wiki/Regression_testing" data-wiki-lang="en" data-wiki-title="Regression testing">regression test</a>,
<a href="https://thenewstack.io/deployment-strategies">deployment strategies/shadow deploy</a>,
teszt stratégiák (top-down, bottom-up, sandwich, big-bang, risky-hardest),
<a href="https://en.wikipedia.org/wiki/Black-box_testing" data-wiki-lang="en" data-wiki-title="Black-box testing">black-box testing</a>,
<a href="https://en.wikipedia.org/wiki/White-box_testing" data-wiki-lang="en" data-wiki-title="White-box testing">white-box testing</a>,
<a href="https://en.wikipedia.org/wiki/Gray_box_testing" data-wiki-lang="en" data-wiki-title="Gray box testing">gray-box testing</a>,
<a href="https://en.wikipedia.org/wiki/Daily_build" data-wiki-lang="en" data-wiki-title="Nightly build">nightly build</a>,
<a href="https://en.wikipedia.org/wiki/Hardware-in-the-loop_simulation" data-wiki-lang="en" data-wiki-title="Hardware-in-the-loop simulation">hardware in the loop (HIL)</a>,
<a href="http://redpine.com.tr/software-in-the-loop-sil.html">software in the loop (SIL)</a>,
<a href="https://en.wikipedia.org/wiki/SMART_criteria" data-wiki-lang="en" data-wiki-title="SMART criteria">SMART objectives</a>,
<a href="https://en.wikipedia.org/wiki/Technical_debt" data-wiki-lang="en" data-wiki-title="Technical debt">technical debt</a>,
<a href="https://en.wikipedia.org/wiki/Cost_estimation_in_software_engineering" data-wiki-lang="en" data-wiki-title="Effort estimation">effort estimation</a></p>
<h1><a class="header" href="#agile-scrum-kanban" id="agile-scrum-kanban">Agile, SCRUM, Kanban</a></h1>
<!-- toc -->
<h2><a class="header" href="#the-agile-manifesto" id="the-agile-manifesto">The Agile Manifesto</a></h2>
<blockquote>
<p>We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:</p>
<ul>
<li><strong>Individuals and interactions</strong> over processes and tools</li>
<li><strong>Working software</strong> over comprehensive documentation</li>
<li><strong>Customer collaboration over</strong> contract negotiation</li>
<li><strong>Responding to change over</strong> following a plan</li>
</ul>
<p>That is, while there is value in the items on the right, we value the items on the left more.</p>
<p>-- <a href="https://www.agilealliance.org/agile101/the-agile-manifesto/">forrás</a></p>
</blockquote>
<ul>
<li><a href="https://www.agilealliance.org/agile101/12-principles-behind-the-agile-manifesto/">The following 12 Principles are based on the Agile Manifesto.</a></li>
<li><a href="https://www.agilealliance.org/agile101/subway-map-to-agile-practices/">Külön érdekes a szoftverfejlesztési metodológiákat metrótérképszerűen összefoglaló ábra</a></li>
</ul>
<h3><a class="header" href="#waterfall-vs-agile" id="waterfall-vs-agile">Waterfall Vs. Agile</a></h3>
<p><img src="https://productivehut.com/wp-content/uploads/2018/06/Classic-Waterfall-Development-Model.png" alt="" /></p>
<ul>
<li><a href="https://www.guru99.com/waterfall-vs-agile.html">Waterfall Vs. Agile: Must Know Differences</a>
<ul>
<li>A többi fejezet is ajánlott</li>
</ul>
</li>
<li><a href="https://www.seguetech.com/waterfall-vs-agile-methodology/">Waterfall vs. Agile: Which is the Right Development Methodology for Your Project?</a></li>
</ul>
<h4><a class="header" href="#v-model" id="v-model">V-Model</a></h4>
<ul>
<li><a href="https://www.guru99.com/v-model-software-testing.html">V-Model in Software Testing</a></li>
</ul>
<p><img src="https://www.guru99.com/images/6-2015/052715_0904_GuidetoSDLC3.png" alt="" /></p>
<h2><a class="header" href="#manifesto-for-software-craftsmanship" id="manifesto-for-software-craftsmanship">Manifesto for Software Craftsmanship</a></h2>
<blockquote>
<p>As aspiring Software Craftsmen we are raising the bar of professional software development by practicing it and helping others learn the craft. Through this work we have come to value:</p>
<ul>
<li>Not only working software,
<ul>
<li>but also <strong>well-crafted software</strong></li>
</ul>
</li>
<li>Not only responding to change,
<ul>
<li>but also <strong>steadily adding value</strong></li>
</ul>
</li>
<li>Not only individuals and interactions,
<ul>
<li>but also <strong>a community of professionals</strong></li>
</ul>
</li>
<li>Not only customer collaboration,
<ul>
<li>but also <strong>productive partnerships</strong></li>
</ul>
</li>
</ul>
<p>That is, in pursuit of the items on the left we have found the items on the right to be indispensable.</p>
<p>-- <a href="https://manifesto.softwarecraftsmanship.org/">forrás</a></p>
</blockquote>
<h2><a class="header" href="#scrum" id="scrum">SCRUM</a></h2>
<p><img src="http://2.bp.blogspot.com/-T9nVdkSCQMo/TrvwKPtRBDI/AAAAAAAAANQ/mWGv4EsmshY/s1600/scrum_process_big.jpg" alt="" /></p>
<ul>
<li><a href="https://www.scrumhub.com/scrum-guide/">Scrum Guide</a>
<ul>
<li>Ez egy igen kiváló összefoglaló, de a webhely elég tré módon oldotta meg a http/https átirányítást, így minden aloldal megnyitása a főoldalra dob.
<ul>
<li>Az aloldalak alján a tartalomjegyzék már jó.</li>
</ul>
</li>
<li>Az alábbi alfejezetek ajánlottak:
<ul>
<li><a href="https://www.scrumhub.com/scrum-guide/team-roles/">Team Roles</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/product-backlog/">Product Backlog</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/release-backlog/">Release Backlog</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/estimations/">Estimations</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/sprints/">Sprints</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/burndowns/">Burndowns</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/expectation-charts/">Expectation Charts</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/daily-standups/">Daily Standups</a></li>
<li><a href="https://www.scrumhub.com/scrum-guide/retrospectives/">Retrospectives</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.scrumguides.org/docs/scrumguide/v2016/2016-Scrum-Guide-US.pdf">The Scrum Guide</a>
<ul>
<li>PDF, 17 oldal</li>
</ul>
</li>
<li><a href="https://manifesto.co.uk/scrum-practice-daily-scrum/">Scrum in practice: the daily Scrum</a></li>
<li><a href="https://www.agilealliance.org/glossary/scrum-of-scrums/">Scrum of Scrums</a></li>
<li><a href="https://reqtest.com/development/how-to-succeed-at-a-sprint-demo/">How to Succeed at a Sprint Demo</a></li>
<li><a href="https://www.youtube.com/watch?v=P6v-I9VvTq4">Scrum Master - Funny movie about The Power of Scrum</a></li>
</ul>
<h3><a class="header" href="#az-egyetem-más-tárgyhoz-fejlesztett-e-tananyaga-scrum-hoz" id="az-egyetem-más-tárgyhoz-fejlesztett-e-tananyaga-scrum-hoz">Az Egyetem más tárgyhoz fejlesztett e-tananyaga SCRUM-hoz</a></h3>
<ul>
<li>Elérhető <a href="http://innovacio.uni-obuda.hu/p/elearning/">innen</a></li>
<li>Ebből az első két blokk (a „<a href="http://innovacio.uni-obuda.hu/p/elearning/course/77">Product owner</a>” és a „<a href="http://innovacio.uni-obuda.hu/p/elearning/course/89">Scrum Master</a>”) releváns, mindkettő 5-5 modul, modulonként egy ~50 oldalas prezentációval.</li>
<li>Teljes más a sztuktúrája mint az SzFMV tárgynak, de kifejezetten hasznos részeket is tartalmaz mint pl. a Product owner / 4. modul: user story szétbontása</li>
<li>A modulokhoz ellenőrző kérdések is vannak, ezek bár független a ZH kérdéseinkről, de a releváns fejezetek önellenőrzésére jók lehetnek</li>
</ul>
<h3><a class="header" href="#cross-functional-team" id="cross-functional-team">Cross-functional team</a></h3>
<p><img src="lectures/../images/cross_functional.png" alt="" /></p>
<p>Akkor tud egy csapat „cross-functional” lenni, ha minden tagja kellőképpen érti a csapat feladatát, így a tagok képesek egymást helyettesíteni. A fenti ábra a csapattagok tudását szemlélteti. Az első esetben csupán elenyésző általános tudással rendelkező emberekről van szó, akik egy nagyon szűk területet ismernek. A <em>cross-functional team</em> esetében is megvan az egyes tagok specifikus tudása ám az kevésbé nyúlik túl a csapat általános ismeretein és kevésbé specifikusabb is.</p>
<h2><a class="header" href="#kanban" id="kanban">Kanban</a></h2>
<ul>
<li><a href="https://www.scrumhub.com/kanban-fundamentals/">Kanban</a></li>
</ul>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Simple-kanban-board-.jpg/800px-Simple-kanban-board-.jpg" width="60%" />
<ul>
<li>a cetlik (taszkok) balról jobbra haladnak,</li>
<li>mindig a leginkább jobbra és felül lévővel kell fogllakozni, hogy a lehető leghamarabb be legyen fejezve</li>
<li>az adott oszlopon belül minél följebb van egy tasz annál magasabb a prioritása</li>
<li>már eszköz függő, de a cetlin célszerű jelezni, hogy
<ul>
<li>ki fogllakozik vele</li>
<li>milyen nehézségű (időigényű)</li>
<li>stb.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#scrumban" id="scrumban">Scrumban</a></h2>
<ul>
<li><a href="https://www.agilealliance.org/what-is-scrumban/">What is Scrumban?</a></li>
</ul>
<!--
UNUSED
https://agilepearls.wordpress.com/category/agile-sw-methodology/
-->
<h1><a class="header" href="#daily-work" id="daily-work">Daily Work</a></h1>
<!-- toc -->
<h2><a class="header" href="#communication" id="communication">Communication</a></h2>
<ul>
<li>A Remote communication strategies kifejezetten hasznos a <a href="https://learn.gitlab.com/all-remote/remote-playbook">GitLab távmunka kézikönyvéből</a>
<ul>
<li>18-26. oldal</li>
</ul>
</li>
</ul>
<blockquote>
<p>I am only responsible for what I said, not for what you understood</p>
</blockquote>
<p>Igaz ez? Miért nem?</p>
<p>Számítsd bele, hogy a másik nem ugyanazzokkal az előismeretekkel rendelkezik, nem ugyanazzal a fogalomkészlettel, terminológiával, esetleg anyanyalvvel.</p>
<ul>
<li><a href="https://www.lullabot.com/articles/effective-communication-part-1-greasing-the-wheels">A Software Developer’s Guide to Project Communication: Part 1</a>
<ul>
<li>a <a href="https://www.lullabot.com/articles/effective-communication-part-2-crossing-the-streams">2. rész</a> is ajánlott</li>
</ul>
</li>
<li><a href="http://www.agilemodeling.com/essays/communication.htm">Communication on Agile Software Teams</a></li>
</ul>
<h2><a class="header" href="#requirement-engineering" id="requirement-engineering">Requirement Engineering</a></h2>
<ul>
<li><a href="https://www.inflectra.com/Ideas/Whitepaper/Principles-of-Requirements-Engineering.aspx">Principles of Requirements Engineering</a></li>
<li>Egy több részes cikk sorozat a Requirements Engineering-ről:
<ul>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-introduction-part-1-6d49001526d3">Introduction (Part 1)</a></li>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-elicitation-analysis-part-2-a02db801f135">Elicitation &amp; Analysis (Part 2)</a></li>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-elicitation-analysis-part-5-2dd9cffafae8">Requirements Specification (Part 3)</a></li>
<li><a href="https://medium.com/omarelgabrys-blog/requirements-engineering-requirements-validation-part-6-29778d7bde24">Requirements Validation (Part 4)</a></li>
</ul>
</li>
<li><a href="https://enfocussolutions.com/requirements-engineering-vs-business-analysis/">Requirements Engineering vs. Business Analysis</a></li>
</ul>
<hr />
<ul>
<li><a href="http://agileforall.com/wp-content/uploads/2018/02/Story-Splitting-Flowchart.pdf">HOW TO SPLIT A USER STORY</a>
<ul>
<li>PDF, 1 oldal, flowchart</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#coding" id="coding">Coding</a></h2>
<!-- ![](https://miro.medium.com/max/978/1*jFw7ZZMoVcsEYM_fS33DBA.gif) -->
<p><img src="lectures/../images/tdd.png" alt="" title="TDD mantra: red, green, refactor" /></p>
<p>A TDD-ről részletesen a <a href="lectures/tdd.html">TDD fejezetben</a>.</p>
<h3><a class="header" href="#cserkész-szabály" id="cserkész-szabály">Cserkész szabály</a></h3>
<blockquote>
<p>Always leave the campground cleaner than you found it</p>
<p>-- Robert C. Martin (Uncle Bob)</p>
</blockquote>
<ul>
<li><a href="https://codeburst.io/leave-the-code-cleaner-than-the-way-you-have-found-it-58c8e4ab3e83">Leave the code cleaner than the way you have found it!</a></li>
</ul>
<h2><a class="header" href="#clean-code" id="clean-code">Clean Code</a></h2>
<blockquote>
<p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability. <a href="https://groups.google.com/forum/#!msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ">source</a></p>
</blockquote>
<p>A viccet félretéve az egész lényege az érthetőség és a karbantarthatóság. Két hét múlva is meg kell értened a saját kódod és nem csak neked.</p>
<!--Elég vázlatos [összefoglalása](https://github.com/lastRoot/notes/wiki/Clean-Code-Rules-in-Java)-->
<h3><a class="header" href="#meaningful-names" id="meaningful-names">Meaningful Names</a></h3>
<p>Az alábbiak Robert C. Martin Clean Code című könyvénből a 2. fejezet (Meaningful Names) alfejezet címei, az idézetek is onnan valók.</p>
<ul>
<li>Use Intention-Revealing Names
<ul>
<li>
<blockquote>
<p><code>int d; // elapsed time in days</code></p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>int elapsedTimeInDays;</code></p>
</blockquote>
</li>
</ul>
</li>
<li>Avoid Disinformation</li>
<li>Make Meaningful Distinctions
<ul>
<li>
<blockquote>
<p>It is not sufficient to add number series or noise words, even though the compiler is satisfied. If names must be different, then they should also mean something different.</p>
</blockquote>
</li>
</ul>
</li>
<li>Use Pronounceable Names
<ul>
<li>
<blockquote>
<p>If you can’t pronounce it, you can’t discuss it without sounding like an idiot. “Well, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?”</p>
</blockquote>
</li>
<li>Külön szempont ez nem angol anyanelyvűeknél, némely szavakat bonyolultabb kiejtenünk</li>
</ul>
</li>
<li>Use Searchable Names
<ul>
<li>
<blockquote>
<p>Single-letter names can ONLY be used as local variables inside short methods. <em>The length of a name should correspond to the size of its scope.</em></p>
</blockquote>
</li>
</ul>
</li>
<li>Avoid Mental Mapping
<ul>
<li>
<blockquote>
<p>Readers shouldn’t have to mentally translate your names into other names they already know.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>clarity is king</p>
</blockquote>
</li>
</ul>
</li>
<li>Avoid Encodings
<ul>
<li>a modern IDE-k esetében már teljesen fölösleges típus vagy szerepjelöléseket tenni a nevekbe</li>
</ul>
</li>
<li>Pick One Word per Concept</li>
<li>Don’t Pun or use humor</li>
<li>Add Meaningful Context
<ul>
<li>
<blockquote>
<p>Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together it’s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method?</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr />
<p>Nincs megjelölve forrás, de <a href="http://bensmith.io/20-tips-for-better-naming">ez az összefogleló</a> is ezen a fejezeten alapszik.</p>
<h3><a class="header" href="#functions" id="functions">Functions</a></h3>
<p>Az alábbiak Robert C. Martin Clean Code című könyvénből a 3. fejezetén alapulnak.</p>
<ul>
<li>A hossza legyen a lehető legrövidebb (akár 2-4 sor, bár személy szerint azt néha túlzásnak tartom)</li>
<li>Do One Thing</li>
<li>Use Descriptive Names
<ul>
<li>egy metódus valamit <em>csinál</em>, tehát kezdődjön igével, pl. <code>increaseSpeed</code></li>
<li>a nevéből legyen egyértelmű, hogy mit csinál</li>
<li>
<blockquote>
<p>Robert C. Martin <a href="https://www.informit.com/articles/article.aspx?p=1323426">The Inverse Scope Law of Function Names</a>: The longer the scope of a function, the shorter its name should be. Functions that are called locally from a few nearby places should have long descriptive names, and the longest function names should be given to those functions that are called from just one place.</p>
</blockquote>
</li>
</ul>
</li>
<li>Function Arguments
<ul>
<li>Lehetőleg ne használj 3-nál több paramétert</li>
<li>
<blockquote>
<p>Flag arguments are ugly [...] loudly proclaiming that this function does more than one thing.</p>
</blockquote>
</li>
</ul>
</li>
<li>Have No Side Effects
<ul>
<li>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">Wikipédiából</a>: an operation, function or expression is said to have a side effect if it modifies some state variable value(s) outside its local environment, that is to say has an observable effect besides returning a value (the main effect) to the invoker of the operation.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Side effects are lies. Your function promises to do one thing, but it also does other hidden things.</p>
</blockquote>
</li>
</ul>
</li>
<li>Prefer Exceptions to Returning Error Codes
<ul>
<li>a korábbiakból már adódik, hogy miért jobb egy FileNotFoundException mint egy ERRCODE_26375</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#comments" id="comments">Comments</a></h3>
<blockquote>
<p>One of the more common motivations for writing comments is bad code. We write a module and we know it is confusing and disorganized. We know it’s a mess. So we say to ourselves, “Ooh, I’d better comment that!” No! You’d better clean it!</p>
<p>-- Robert C. Martin: Clean Code, pp 55.</p>
</blockquote>
<ul>
<li>Gyakori a kód strukturálása kommentekkel, ilyenkor célszerű függvényeket használni inkább</li>
<li>Kerülendő a TODO és a FIXME a kommentekben, ez azt jelenti, hogy nem vagy készen</li>
<li>Kommentezni ajánlott viszont -szerintem- a domain specifikus részeket, amelyek megértését nem feltétlenül lehet elvárni egy fejlesztőtől. Pl. egy fizikai számítás.</li>
<li>Továbbá nem haszontalan a dokumentációs kommentezés pl. Javadoc, kivéve ha egy <code>increaseSpeed</code> metódus kommentje annyi, hogy <em>&quot;this method increases the speed&quot;</em>, sokkal többet mondana az, hogy mennyivel, milyen korlátok között stb. amelyek révén aztán hasznos lesz a generált API dokumentáció anélkül, hogy a kódba kellene nézni.</li>
</ul>
<!--
- https://www.freecodecamp.org/news/code-comments-the-good-the-bad-and-the-ugly-be9cc65fbf83/
- [When Good Comments Go Bad](https://blog.codinghorror.com/when-good-comments-go-bad/)
-->
<hr />
<center>
    <img src="http://cdn.ttgtmedia.com/ITKE/uploads/blogs.dir/8/files/2008/07/goodcomments.jpg" width="320px" />
</center>
<hr />
<p><img src="https://miro.medium.com/max/1400/0*g6BXiTlE5fsgAFyI.png" alt="" /></p>
<h2><a class="header" href="#verziókezelők" id="verziókezelők">Verziókezelők</a></h2>
<p><img src="http://smutch.github.io/VersionControlTutorial/_images/vc-xkcd.jpg" alt="" /></p>
<h3><a class="header" href="#mi-a-verziókezelő" id="mi-a-verziókezelő">Mi a verziókezelő?</a></h3>
<blockquote>
<p>Version control, a.k.a. revision control / source code management, is basically a system for recording and managing changes made to files and folders. It is commonly used to manage source code, however, it is also well suited to tracking changes to any kind of file which contains mostly text.</p>
<p>-- <a href="http://smutch.github.io/VersionControlTutorial/pages/0-intro.html#what-is-version-control">forrás</a></p>
</blockquote>
<p>Az ember hajlamos ad-hoc módon is verziózni a munkáját, pl.<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<p><img src="http://smutch.github.io/VersionControlTutorial/_images/intro1.png" alt="" /></p>
<p>Több szolgáltatás és szoftver alapból tartalmaz verziókövetést, pl. a Dropbox, Google Drive, stb. is verziózza a feltöltött állományokat; az MS Word még <a href="https://support.microsoft.com/en-us/office/combine-document-revisions-f8f07f09-4461-4376-b041-89ad67412cfe?ui=en-us&amp;rs=en-us&amp;ad=us">merge-elni is tudja az egyes verziókat</a>.</p>
<p>Michael Ernst <a href="https://homes.cs.washington.edu/%7Emernst/advice/version-control.html">összefoglalója alapján</a>:</p>
<ul>
<li><strong>Version control enables multiple people to simultaneously work on a single project.</strong> Each person edits his or her own copy of the files and chooses when to share those changes with the rest of the team. Thus, temporary or partial edits by one person do not interfere with another person's work.</li>
<li>Version control also enables one person you to use multiple computers to work on a project, so it is valuable even if you are working by yourself.</li>
<li><strong>Version control integrates work done simultaneously by different team members.</strong> In most cases, edits to different files or even the same file can be combined without losing any work. In rare cases, when two people make conflicting edits to the same line of a file, then the version control system requests human assistance in deciding what to do.</li>
<li><strong>Version control gives access to historical versions of your project.</strong> This is insurance against computer crashes or data lossage. If you make a mistake, you can roll back to a previous version. You can reproduce and understand a bug report on a past version of your software. You can also undo specific edits without losing all the work that was done in the meanwhile. For any part of a file, you can determine when, why, and by whom it was ever edited.</li>
</ul>
<h3><a class="header" href="#mit-érdemes-verziókezelni" id="mit-érdemes-verziókezelni">Mit érdemes verziókezelni</a></h3>
<blockquote>
<p>&quot;In practice, everything that has been created manually should be put in version control, including programs, original field observations, and the source files for papers.&quot;</p>
<p>-- Best Practices for Scientific Computing; Wilson et al. 2012 (<a href="https://arxiv.org/abs/1210.0530">arXiv:1210.0530</a>)</p>
</blockquote>
<p>Az ehhez a jegyzethez készített ábrák és azok forrása is verziókezelés alatt van, ezek a <code>.png</code> és <code>.dia</code> állományok a <code>/src/images/</code> mappában, utóbbiak valójában egy <a href="https://wiki.gnome.org/Apps/Dia">diagramszerkesztő alkalmazás</a> XML alapú forrásfájljai.</p>
<!--
### Verziókezelési modellek

- Lock-Modify-Unlock
- Copy-Modify-Merge
-->
<ul>
<li><a href="https://tortoisesvn.net/docs/nightly/TortoiseSVN_en/tsvn-basics-versioning.html">Ez az írás</a> összefoglalja a verziókezelési modelleket (Lock-Modify-Unlock, Copy-Modify-Merge), <a href="https://homes.cs.washington.edu/%7Emernst/advice/version-control.html">emez pedig</a> összehasonlítja a centralizált és az elosztott verziókezelőket.</li>
<li><a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control">About Version Control</a>
<ul>
<li>a Git könyv első fejezete, rövid összefoglaló</li>
</ul>
</li>
<li>gyakorlati oldalról lást <a href="lectures/../git.html">Git</a> fejezet</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>http://smutch.github.io/VersionControlTutorial/pages/0-intro.html#what-is-version-control</p>
</div>
<h3><a class="header" href="#centralizált-verziókezelő" id="centralizált-verziókezelő">Centralizált verziókezelő</a></h3>
<p><img src="https://homes.cs.washington.edu/%7Emernst/advice/version-control-fig2.png" alt="centralized_version_control" /></p>
<h3><a class="header" href="#elosztott-verziókezelő" id="elosztott-verziókezelő">Elosztott verziókezelő</a></h3>
<p><img src="https://homes.cs.washington.edu/%7Emernst/advice/version-control-fig3.png" alt="distributed_version_control" /></p>
<h3><a class="header" href="#branching" id="branching">Branching</a></h3>
<ul>
<li><a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">Git Branching - Basic Branching and Merging</a></li>
<li><a href="lectures/../git.html#interakt%C3%ADv-online-oktat%C3%B3-anyagok">Gyakorlati oktatóanyagok</a></li>
</ul>
<p>Az „<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>” című posztban lehet olvasni egy szélesebb körben kedvelt modellről. A félév során használt többé-kevésbé ehhez hasonló.</p>
<p><img src="https://www.rittmanmead.com/blog/content/images/2017/01/gitflow.png" alt="" /></p>
<h4><a class="header" href="#további-írások-a-témában" id="további-írások-a-témában">További írások a témában</a></h4>
<ul>
<li><a href="https://www.gitprime.com/the-definitive-guide-to-forks-and-branches-in-git/">A <em>fork</em> és a <em>branch</em> közötti különbségekről</a></li>
<li><a href="https://gist.github.com/jbenet/ee6c9ac48068889b0912">a simple git branching model</a></li>
<li><a href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#oneflow-advantages">OneFlow – a Git branching model and workflow</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">Comparing Workflows</a></li>
<li><a href="https://www.atlassian.com/blog/git/git-branching-and-forking-in-the-enterprise-why-fork">Git branching and forking in the enterprise: why fork?</a></li>
<li><a href="https://blog.scottlowe.org/2015/01/27/using-fork-branch-git-workflow/">Using the Fork-and-Branch Git Workflow</a></li>
<li><a href="https://stackoverflow.com/a/34343080/4737417">Stackoverflow / Forking vs. Branching in GitHub</a></li>
<li><a href="https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/">A succesful Git branching model considered harmful</a></li>
<li><a href="https://stxnext.com/blog/2018/02/28/escape-merge-hell-why-i-prefer-trunk-based-development-over-feature-branching-and-gitflow/">Escape from Merge Hell: Why I Prefer Trunk-Based Development Over Feature Branching and GitFlow</a></li>
</ul>
<h3><a class="header" href="#commit-üzenetek" id="commit-üzenetek">Commit üzenetek</a></h3>
<p><img src="https://www.explainxkcd.com/wiki/images/d/de/git_commit.png" alt="xkcd 1296" /></p>
<p>A <a href="https://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a> egy hosszabb, példákkal illusztrált írás a jó commit üzenetekről, amely <a href="https://chris.beams.io/posts/git-commit/#seven-rules">hét szabályban</a> foglalja össze, hogy mire kell figyelni. Ezt egészíteném ki egy nyolcadikkal.</p>
<ol>
<li><a href="https://chris.beams.io/posts/git-commit/#separate">Separate subject from body with a blank line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#limit-50">Limit the subject line to 50 characters</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#capitalize">Capitalize the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#end">Do not end the subject line with a period</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#imperative">Use the imperative mood in the subject line</a></li>
<li><a href="https://chris.beams.io/posts/git-commit/#wrap-72">Wrap the body at 72 characters</a>
<ul>
<li>ez a legkevésbé fontos</li>
</ul>
</li>
<li><a href="https://chris.beams.io/posts/git-commit/#why-not-how">Use the body to explain what and why vs. how</a></li>
<li><strong>Reference the issue!</strong></li>
</ol>
<h4><a class="header" href="#miért-fontos-a-8-pont" id="miért-fontos-a-8-pont">Miért fontos a 8. pont?</a></h4>
<p>Valójában (bizonyos szempontból) az issue behivatkozása a legfontosabb, méghozzá a <strong>visszakövethetőség</strong> (traceability) miatt.</p>
<p><img src="lectures/../images/traceability_via_commit.png" alt="" /></p>
<p>Minden módosítás (a verziókövető rendszerben) rendelkezik egy azonosítóval, amelyhez társul, hogy ki és mikor végezte el a módosítást. Valamit egy üzenet, amely -- jó esetben -- leírja, hogy mi volt ez a módosítás. A visszakövethetőség egy adott szintig tehát szerves része a verziókövető rendszereknek.</p>
<p>A módosítások azonban nem csak úgy ötletszerűen történnek, hanem valamilyen feladat által meghatározott célból. Pl. jelenítsd meg a műszerfalon az autó pillanatnyi sebességét (feature), vagy javítsd ki pixel/s -&gt; km/h átváltást, mert kerekítési hiba miatt értelmetlen érték jelenik meg (bugfix).</p>
<p>Ugyanakkor a feladatok (task) sem csak úgy lógnak a levegőben, jellemzően kapcsolódnak egy user story-hoz (különösen a feature-ök), de biztosan kapcsolódnak egy sprinthez (hiszen beütemezték a megoldását valamikorra), van felelősük, határidejük, stb. Úgy általában van véve egy kontextusuk. Az issue (más néven task) tartalmazza az adott feladat pontos részleteit, az issue/task trackerben akár a megoldás teljes vitafolyamata megtalálható. Pl. ki hogyan akarta implementálni, milyen érvek és ellenérvek merültek fel az egyes implementációs lehetőségek mellett/ellen, hogyan jutott a fejlesztőcsapat konszenzusra, vagy ki hagyta jóvá az adott módosítást, ki döntött arról, hogy melyik sprintbe kerüljön be, stb.</p>
<p>A visszakövethetőség nem csak addig a pontig érdekes és fontos, hogy ki írta át a változó típusát (pl.), hanem a teljes tervezési/döntés folyamatig visszamenőleg.</p>
<p>Mi van akkor ha a döntés egy face-to-face meetingen (pl. standup), skype konferenciahíváson vagy egyéb nem írásos formában történt?
(A szó elszáll, írás megmarad...)</p>
<p>Ebben az esetben, az issue kiváló hely arra, hogy írásban is rögzítve legyenek az elhangzottak. Pl. YYYY-MM-DD-ei megbeszélés alapján az XY library segítségével fogom implementálni az analóg fordulatszámkijelzőt. Akár explicit írásos jóváhagyást is lehet kérni...</p>
<h4><a class="header" href="#további-iskolák" id="további-iskolák">További „iskolák”</a></h4>
<ul>
<li>Az <a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit">AngularJS Git Commit Message Conventions</a> a commit üzenet fejlécét a <code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code> szabály szerint követeli meg.
<ul>
<li>ahol <a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#type">típus</a> lehet build, ci, docs, feat, fix, perf, refactor, style vagy test</li>
<li>valójában a 1., 4. és 5. pontot ez is megköveteli; a 3.-al pont szembemegy, aminek oka, hogy a tárgy típusmegjelöléssel kezdődik, nem a tárgy szövegével</li>
<li>a tárgy és törzs sorhosszára 100 karakteres limitet ad, szemben a fenti hagyományos (akár úgy is lehet érteni, hogy elavult) terminálméretekre szabott korlátaival</li>
</ul>
</li>
<li>Egy másik, az Angularéhoz nagyon hasonló a <a href="http://conventionalcommits.org/">Conventional Commits</a></li>
<li>Ezek előnye lehet -megfelelő tooling mellett- pl. az automatizált changlelog generálás
<ul>
<li>nálunk nincs ilyesmire beállított eszköz</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#mire-jó-még-a-commit-üzenet" id="mire-jó-még-a-commit-üzenet">Mire jó még a commit üzenet?</a></h4>
<p>Például arra is alkalmas, hogy <a href="https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword">lezárjunk vele egy issue-t</a>. Ha a commit üzenet törzse tartalmazza a <em>close</em>, <em>closes</em>, <em>closed</em>, <em>fix</em>, <em>fixes</em>, <em>fixed</em>, <em>resolve</em>, <em>resolves</em> vagy <em>resolved</em> utasítások egyikét, akkor a GH automatikusan zárja az issue-t amint az a fő ágba (master) került. Pl.</p>
<pre><code>Fix px/s -&gt; km/h conversion #28

Fixes #28
</code></pre>
<h3><a class="header" href="#mikor-commit-oljunk" id="mikor-commit-oljunk">Mikor commit-oljunk?</a></h3>
<p>A fentiekből már látszik, hogy az egésznek akkor van értelme, ha egy-egy commit egy jól megválasztott mértékű módosítást rögzít. Az a megközelítés, hogy a munkanap végén nyomok egy commitot valami olyasféle üzenettel, hogy <code>Changes on YYYY-MM-DD</code> nem nagyon szolgálja a visszakövethetőséget.</p>
<p>Egy taszk hossza 1-4 óra (főállású fejlesztőre értelmezve), de fontos, hogy egy megszakítás nélkül elvégezhető feladat legyen. Ez azt jelenti, hogy egy taszk egyenlő egy committal? Nem. Egy taszk megoldása természetesen több commitból is állhat.</p>
<p>A <a href="https://dev.to/gonedark/when-to-make-a-git-commit">When to make a Git Commit</a> poszt<sup class="footnote-reference"><a href="#1">1</a></sup> alapján (is), azt mondanám, hogy akkor érdemes commitolni, ha:</p>
<ol>
<li>Befejeztem egy egységnyi munkát.</li>
<li>Olyan módosítást végeztem, amit esetleg visszavonnék.</li>
</ol>
<p>Az egységnyi munka módosított sorok és fájlok tekintetében rendkívül változó lehet. Egy bugfix pl. állhat egyetlen karakter módosításából, de egy refaktorálás során egy metódus átnevezése járhat tucatnyi fájl módosításával (ahol az adott metódus használva volt). Ugyanakkor a metódusátnevezés után biztosan érdemes lehet commitolni, egyéb módosítást már nem csapnék hozzá.</p>
<p>Ha a commit üzenetbe azt írnád, hogy <code>Rename foobar method and fix typo in the comment #42</code> már biztosan két külön commitra lenne szükséged.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>a hozzá tartozó kommenteket is érdemes átfutni</p>
</div>
<h2><a class="header" href="#review" id="review">Review</a></h2>
<ul>
<li><a href="lectures/./review.html">Review fejezet</a></li>
</ul>
<h3><a class="header" href="#a-tárgy-során" id="a-tárgy-során">A tárgy során</a></h3>
<p><img src="lectures/../images/proc3.png" alt="review process" /></p>
<!--## Java kódformázás-->
<h1><a class="header" href="#test-driven-development" id="test-driven-development">Test Driven Development</a></h1>
<!-- toc -->
<h2><a class="header" href="#tesztelés" id="tesztelés">Tesztelés</a></h2>
<p>Az alábbi ábra mutatja a tesztelések eloszlását hagyományos és agilis fejlesztéseknél. Az egész lényege, hogy minél előbb és a fejlesztőhöz a lehető legközelebb derüljön ki a hiba, mert annál gyorsabb és olcsóbb annak javítása. Könnyen belátható, hogy egy leszállított terméket kell visszahívni az körülményesebb mintha a fejlesző a <em>run tests</em> gombra nyomva azonnal, helyben az adott kód részlet írása közben (amikor még az a kontextus van a fejében) kap egy képet arról, hogy mi nem jó.
De még midnig jobb ha pl. sprinten belül egy automatizált integrációs teszt fogja meg a hibát, stb.</p>
<p><img src="http://www.adapttransformation.com/wp-content/uploads/flippyramid.png" alt="test pyramids" /></p>
<h2><a class="header" href="#tdd" id="tdd">TDD</a></h2>
<p><img src="https://miro.medium.com/max/988/0*rxhD9QmJ6dBghRj1." alt="" /></p>
<ul>
<li><a href="https://www.guru99.com/test-driven-development.html">What is Test Driven Development?</a></li>
<li><a href="http://agiledata.org/essays/tdd.html">Introduction to Test Driven Development (TDD)</a></li>
<li><a href="https://www.agilealliance.org/glossary/tdd">TDD</a></li>
<li><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">TDD Laws</a>
<ul>
<li>Az eredeti egy refaktorált verziója <a href="http://www.javiersaldana.com/articles/tech/refactoring-the-three-laws-of-tdd">innen</a>:
<ol>
<li>Write production code only to make a failing unit test pass.</li>
<li>Write only enough of a unit test to fail.</li>
<li>Write only enough production code to make the failing unit test pass.</li>
</ol>
</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD wikiről</a></li>
</ul>
<h2><a class="header" href="#tdd-cycle" id="tdd-cycle">TDD cycle</a></h2>
<!-- ![](https://miro.medium.com/max/978/1*jFw7ZZMoVcsEYM_fS33DBA.gif) -->
<p><img src="lectures/../images/tdd.png" alt="" title="TDD mantra: red, green, refactor" /></p>
<blockquote>
<p>As the tests get more specific, the code gets more generic.</p>
<p>-- <a href="https://sites.google.com/site/unclebobconsultingllc/home/articles/as-the-tests-get-more-specific-the-code-gets-more-generic">Uncle Bob</a></p>
</blockquote>
<h2><a class="header" href="#red" id="red">Red</a></h2>
<ul>
<li>tesztelj egyszerre egy dolgot</li>
<li>a teszt legyen nagyon egyszerű</li>
<li>folyamatosan növeld teszt(esetek) komplexitását</li>
<li><a href="lectures/./legacy_code.html#mocking">mockold a függőségeket</a></li>
</ul>
<h3><a class="header" href="#writing-unit-tests" id="writing-unit-tests">Writing Unit Tests</a></h3>
<ul>
<li><a href="https://medium.com/@justborromeo/writing-unit-tests-for-dummies-e4282bbfef7c">Writing Unit Tests For Dummies</a></li>
<li><a href="http://www.vogella.com/tutorials/JUnit/article.html">Unit Testing with Junit</a></li>
</ul>
<h2><a class="header" href="#green" id="green">Green</a></h2>
<ul>
<li>a lehető legegszerűbb kóddal felelj meg a teszt által támasztott követelménynek</li>
<li>nem baj ha csúnya, ebben a lépésben csak az számít, hogy a teszt ne bukjon</li>
<li>amint a teszt zöld (és másik sem bukik), ez a fázis kész</li>
</ul>
<h2><a class="header" href="#refactor" id="refactor">Refactor</a></h2>
<ul>
<li><a href="https://martinfowler.com/books/refactoring.html">Refactoring by Martin Fowler</a></li>
<li><a href="https://web.archive.org/web/20170606150219/http://www.integralist.co.uk/posts/refactoring-techniques.html">Refactoring methods</a></li>
<li><a href="https://refactoring.com/catalog/">Refactoring methods</a></li>
<li><a href="http://www.methodsandtools.com/archive/archive.php?id=4">Refactoring Java Code</a></li>
<li><a href="https://www.targetprocess.com/blog/2009/11/refactoring-vs-rewrite/">Refactoring vs. Rewrite</a></li>
</ul>
<h3><a class="header" href="#transformation-priority-premise" id="transformation-priority-premise">Transformation Priority Premise</a></h3>
<p>Beragadás esetén visszalépés, vagy másik módszert kell választani. A beragadás megelőzésére van a TPP.</p>
<ul>
<li><a href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">Robert C. Martin (Uncle Bob) írása</a>, összefoglalásul pedig a transformációk:
<ol>
<li>({} -&gt; nil) no code at all -&gt; code that employs nil</li>
<li>(nil -&gt; constant)</li>
<li>(constant -&gt; constant+) a simple constant to a more complex constant</li>
<li>(constant -&gt; scalar) replacing a constant with a variable or an argument</li>
<li>(statement -&gt; statements) adding more unconditional statements.</li>
<li>(unconditional -&gt; if) splitting the execution path</li>
<li>(scalar -&gt; array)</li>
<li>(array -&gt; container)</li>
<li>(statement -&gt; tail-recursion)</li>
<li>(if -&gt; while)</li>
<li>(expression -&gt; function) replacing an expression with a function or algorithm</li>
<li>(variable -&gt; assignment) replacing the value of a variable.</li>
</ol>
</li>
<li><a href="https://vimeo.com/97516288">Advanced TDD: The Transformation Priority Premise</a>
<ul>
<li>1 órás videó, Robert C. Martintól</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#coding-dojo" id="coding-dojo">Coding Dojo</a></h2>
<ul>
<li><a href="https://medium.com/@lucascaixeta/coding-dojo-4e0b1ea69735">Coding Dojo</a></li>
</ul>
<h2><a class="header" href="#egyéb-a-tdd-hez-lazábban-kapcsolódó-anyagok" id="egyéb-a-tdd-hez-lazábban-kapcsolódó-anyagok">Egyéb a TDD-hez (lazábban) kapcsolódó anyagok</a></h2>
<ul>
<li>Behavior Driven Development
<ul>
<li>Ez a TDD kiterjesztése, lényege, hogy a megrendelővel (és nem is annyira egy menedzserrel, hanem sokkal inkább egy domain szakértőjével) való egyeztetés folyamán, egy strukturált, ám természetes nyelvi szöveggel leírt „szabályok” formájában kerül leírásra az elvárt működés. Ezek alapján aztán a fejlesztő <em>több tesztet is ír</em> (szemben a TDD-vel, ahogy egyszerre szigorúan egyet), majd a tesztek összességének megfelelő kódot ír</li>
<li><a href="https://www.toptal.com/freelance/your-boss-won-t-appreciate-tdd-try-bdd">TDD vs. BDD</a></li>
<li><a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Wikipédia BDD cikke</a></li>
<li><a href="https://www.agilealliance.org/glossary/bdd/">Agile alliance összefoglalója a BDD-ről</a></li>
</ul>
</li>
<li><a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">Readme Driven Development</a>
<ul>
<li>Különösen ajánlom elolvasni, kb. egy oldal</li>
</ul>
</li>
<li><a href="http://www.methodsandtools.com/archive/archive.php?id=72">Acceptance Test Driven Development (ATDD)</a></li>
<li><a href="https://www.destroyallsoftware.com/talks/ideology">types vs. tests</a>
<ul>
<li>video ~21 min</li>
</ul>
</li>
<li><a href="https://dmerej.info/blog/post/trying-mypy/">I don't need types</a>
<ul>
<li>blogposzt a típusosságról</li>
</ul>
</li>
</ul>
<!--
https://diveintopython3.net/unit-testing.html
![](https://www.agilecoachjournal.com/wp-content/uploads/2014/01/AgileTestingPyramid2.jpg)
-->
<h1><a class="header" href="#legacy-code" id="legacy-code">Legacy code</a></h1>
<p>Ez a fejezet gyakorlatilag teljes egészében Michael Feathers <em>Working Efficiently with Legacy Code</em> c. könyvén alapszik. <a href="https://www.slideshare.net/nashjain/working-effectively-with-legacy-code-presentation">Itt elérhető</a> egy prezentáció a szerzőtől.</p>
<!-- toc -->
<!--
- [Jeremy Thurgood „Surviving a Legacy Codebase” című prezentációja](https://jerith.github.io/pyconza2017-surviving-a-legacy-codebase/#/)
    - Ez egy `reveal.js` prezentáció, a fejezetek között a jobbra/balra nyilakkal, a fejezeteken belül a fel/le nyilakkal lehet lépkedni, vagy simán space-el végig lehet nyomogatni mint egy PowerPoint prezit.
    - Mivel egy Python konferencián hangzott el, ami pár sornyi kód szerepel benne, az Python-ul van.
-->
<h2><a class="header" href="#mi-a-legacy-code" id="mi-a-legacy-code">Mi a Legacy Code?</a></h2>
<blockquote>
<p>Code without tests is bad code. It doesn’t matter how well written it is; it doesn’t matter how pretty or object-oriented or well-encapsulated it is. With tests, we can change the behavior of our code quickly and verifiably. Without them, we really don’t know if our code is getting better or worse.</p>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Preface</p>
</blockquote>
<ul>
<li><a href="https://dzone.com/articles/defining-legacy-code">További definíciók</a></li>
<li>Legacy Code
<ul>
<li><a href="http://programmers.stackexchange.com/questions/122014/what-are-the-key-points-of-working-effectively-with-legacy-code">What are the key points of Working Effectively with Legacy Code?</a></li>
<li><a href="http://www.slideshare.net/nashjain/working-effectively-with-legacy-code-presentation">Working Effectively With Legacy Code</a>
<ul>
<li>prezentáció</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-legacy-code-dilemma" id="the-legacy-code-dilemma">The Legacy Code Dilemma</a></h3>
<blockquote>
<p>When we change code, we should have tests in place. To put tests in place, we often have to change code.</p>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Part I / Chapter 2</p>
</blockquote>
<h3><a class="header" href="#code-smells" id="code-smells">Code Smells</a></h3>
<ul>
<li><a href="https://blog.codinghorror.com/code-smells/">Code Smells</a></li>
</ul>
<h2><a class="header" href="#changing-software" id="changing-software">Changing Software</a></h2>
<blockquote>
<table><thead><tr><th></th><th>adding a feature</th><th>fix a bug</th><th>refactor</th><th>optimizing</th></tr></thead><tbody>
<tr><td>structure</td><td>changes</td><td>changes</td><td>changes</td><td></td></tr>
<tr><td>functionality</td><td>changes</td><td></td><td></td><td></td></tr>
<tr><td>new funcionality</td><td></td><td>changes</td><td></td><td></td></tr>
<tr><td>resource usage</td><td></td><td></td><td></td><td>changes</td></tr>
</tbody></table>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: WORK EFFECT LEG CODE p1. pp 6. Prentice Hall Professional.</p>
</blockquote>
<h2><a class="header" href="#the-legacy-code-algorithm" id="the-legacy-code-algorithm">The legacy code algorithm</a></h2>
<ul>
<li><a href="https://bssw.io/items/working-effectively-with-legacy-code">Working Effectively with Legacy Code</a></li>
<li><a href="https://wikimatze.de/books/working-effectively-with-legacy-code/">Matthias Günther jegyzetei a „Working Effectively with Legacy Code” könyvből</a></li>
<li><a href="https://gist.github.com/jeremy-w/6774525">Jeremy W. Sherman jegyzetei a „Working Effectively with Legacy Code” könyvből</a></li>
</ul>
<h2><a class="header" href="#sensing--separation" id="sensing--separation">Sensing &amp; Separation</a></h2>
<blockquote>
<ol>
<li>Sensing — We break dependencies to sense when we can’t access values our code computes.</li>
<li>Separation — We break dependencies to separate when we can’t even get a piece of code into a test harness to run.</li>
</ol>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Part I / Chapter 3</p>
</blockquote>
<h2><a class="header" href="#mocking" id="mocking">Mocking</a></h2>
<ul>
<li><a href="http://blog.tremblay.pro/2017/09/mocks.html">Type of Mocks</a></li>
<li><a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da">Test Doubles — Fakes, Mocks and Stubs</a>
<ul>
<li>ez egy másik írás, bővebb, ábrákkal, Java kódokkal...</li>
</ul>
</li>
<li><a href="http://www.martinfowler.com/bliki/TestDouble.html">Test Doubles</a>
<ul>
<li>az úriember blogján egyébként rengeteg hasonló hosszúságú, elég releváns bejegyzés van</li>
</ul>
</li>
<li><a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests">How to write good tests</a></li>
</ul>
<h2><a class="header" href="#seams" id="seams">Seams</a></h2>
<blockquote>
<p>A seam is a place where you can alter behavior in your program without editing in that place.</p>
<p>-- Feathers, M. (2004). Working Effectively with Legacy Code: Part I / Chapter 4</p>
</blockquote>
<ul>
<li><a href="https://medium.com/@biratkirat/working-effectively-with-legacy-code-changing-software-part-1-chapter-4-b997b78fc0a2">Nagyon rövid kivonata a Working Effectively with Legacy Code 1. rész / 4. fejezetének</a></li>
</ul>
<h1><a class="header" href="#solid" id="solid">SOLID</a></h1>
<p><img src="https://devopedia.org/images/article/177/8101.1558682601.png" alt="" /></p>
<ul>
<li><a href="http://www.codemag.com/article/1001061">S.O.L.I.D. Software Development, One Step at a Time</a>
<ul>
<li>igen részletes írás</li>
</ul>
</li>
<li><a href="https://devopedia.org/solid-design-principles">SOLID Design Principles</a></li>
<li><a href="https://youtu.be/llGgO74uXMI">Core Design Principles for Software Developers by Venkat Subramaniam</a>
<ul>
<li>Hosszabb (2,5 órás) előadás, a <a href="https://www.youtube.com/watch?v=llGgO74uXMI&amp;feature=youtu.be&amp;t=3353">Single Responsibility</a> inenntől, ez olyan 25 perc</li>
</ul>
</li>
</ul>
<!--
- [**S**ingle-responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle)
- [**O**pen–closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)
- [**L**iskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
- [**I**nterface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
- [**D**ependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)

https://softwareengineering.stackexchange.com/questions/122014/what-are-the-key-points-of-working-effectively-with-legacy-code
-->
<h1><a class="header" href="#review-1" id="review-1">Review</a></h1>
<p><img src="https://i.pinimg.com/originals/e2/7e/30/e27e30d4a5664bc266aff8b03ccc4028.jpg" alt="" /></p>
<p>Az első két cikk inkább technikai, számokkal meg minden, a harmadik (ez kétrészes), sokkal inkább az emberi oldalt taglalja, igen jól!</p>
<ul>
<li><a href="https://smartbear.com/learn/code-review/what-is-code-review/">What is Code Review?</a></li>
<li><a href="https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/">Best Practices for Code Review</a></li>
<li><a href="https://mtlynch.io/human-code-reviews-1/">How to Do Code Reviews Like a Human (Part One)</a>
<ul>
<li><a href="https://mtlynch.io/human-code-reviews-2/">Part Two</a></li>
</ul>
</li>
<li><a href="https://phauer.com/2018/code-review-guidelines/">Code Review Guidelines for Humans</a></li>
<li><a href="https://www.evoketechnologies.com/blog/code-review-checklist-perform-effective-code-reviews/">Code Review Checklist – To Perform Effective Code Reviews</a></li>
</ul>
<h2><a class="header" href="#review-típusok" id="review-típusok">Review típusok</a></h2>
<ul>
<li><a href="http://tryqa.com/what-are-the-types-of-review/">What are the types of review?</a>
<ul>
<li>Nem említi az informálist</li>
</ul>
</li>
<li><a href="https://www.slideshare.net/Chandukar/istqb-foundation-chapter-3">Prezentáció a review typusokról, hasonlóan tárgyalja mint a Bosch-os</a>
<ul>
<li>a 27. diáig ajánlom</li>
</ul>
</li>
<li><a href="http://tryqa.com/what-is-formal-review/">Formális review részei</a></li>
</ul>
<h3><a class="header" href="#sorrendben" id="sorrendben">Sorrendben</a></h3>
<ol>
<li>informal
<ul>
<li>Ez akár csak annyi, hogy megkérsz egy kollegát, hogy „nézz már rá erre picit, szerinted ez így jó?”, gyorsan tud valami visszejelzést adni, de semmi nyoma nem marad. A pair programming folyamatos informáls review.</li>
</ul>
</li>
<li><a href="http://tryqa.com/what-is-walkthrough-in-software-testing/">walkthrough</a>
<ul>
<li>a GitHub-os review kb. ezen a szinten van, visszakövethető módon dokumentált a GH felületének hála, bár nem egy meeting folyamán történik a review, hanem egyénileg (így nincs is vezetője, bár lehetne úgy is csinálni).</li>
</ul>
</li>
<li><a href="http://tryqa.com/what-is-technical-review-in-software-testing/">technical</a></li>
<li><a href="http://tryqa.com/what-is-inspection-in-software-testing/">inspection</a></li>
</ol>
<h3><a class="header" href="#Összefoglaló-táblázat-a-fentebbiek-alapján" id="Összefoglaló-táblázat-a-fentebbiek-alapján">Összefoglaló táblázat a fentebbiek alapján</a></h3>
<table><thead><tr><th align="center">type</th><th align="center">formality</th><th align="center">led by</th><th align="center">effort</th><th align="center">documentation</th></tr></thead><tbody>
<tr><td align="center">informal</td><td align="center">not formal</td><td align="center">noone</td><td align="center">minimal</td><td align="center">undocumented</td></tr>
<tr><td align="center">walkthrough</td><td align="center">not formal<sup class="footnote-reference"><a href="#1">1</a></sup></td><td align="center">authors</td><td align="center">very low</td><td align="center">normal, fault-finding</td></tr>
<tr><td align="center">technical</td><td align="center">less formal</td><td align="center">trained moderator, NOT the author</td><td align="center">moderate</td><td align="center">more detailed</td></tr>
<tr><td align="center">inspection</td><td align="center">most formal</td><td align="center">trained moderator</td><td align="center">high</td><td align="center">thorough; based on  standards, checklists</td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Sometimes it can be somewhat formal.</p>
</div>
<!--
https://www.cs.jhu.edu/~jorgev/cs106/bug.pdf
https://www.slideshare.net/philipmjohnson/06softwarereview
https://stackoverflow.com/questions/3533348/how-does-this-code-generate-the-map-of-india
https://www.tutorialspoint.com/software_testing_dictionary/code_walkthrough.htm
-->
<h1><a class="header" href="#continuous-integration" id="continuous-integration">Continuous Integration</a></h1>
<ul>
<li><a href="https://www.atlassian.com/continuous-delivery/continuous-integration">What is Continuous Integration</a></li>
<li><a href="https://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a></li>
</ul>
<p><img src="https://pepgotesting.com/wp-content/uploads/2015/02/CI.png" alt="" /></p>
<p>Ennek alapja a verziókövetés, a fejlesztő pusholja a módosításait a szerverre, amely lefordítja a kódot, lefuttatja a teszteket (és egyéb elemzéseket), ezek sikerességéről visszajelzést ad. Kicsit bővebben <a href="lectures/ci.html#ci-k%C3%B6rnyzet">itt</a>.</p>
<h2><a class="header" href="#interrupts" id="interrupts">Interrupts</a></h2>
<p><img src="https://i0.wp.com/www.brightdevelopers.com/wp-content/uploads/2018/05/ProgrammerInterrupted.png?resize=267%2C1024&amp;ssl=1" alt="interrupt_comic" /></p>
<p><a href="https://www.brightdevelopers.com/the-cost-of-interruption-for-software-developers/">The Cost of Interruption for Software Developers</a></p>
<p>Az automatizálás csökkenti az interruptokat, a költségeket és azonnali visszajelzést ad!</p>
<h2><a class="header" href="#automation" id="automation">Automation</a></h2>
<ul>
<li><a href="https://www.developerdotstar.com/mag/articles/automate_software_process.html">Automating Software Development Processes</a></li>
</ul>
<!--how does it work

version control
build automation
self-stesting-->
<h2><a class="header" href="#build-scripts" id="build-scripts">Build scripts</a></h2>
<p>Az egész CI/CD lelke egy adag script, amelyben le vannak írva az automatizált lépések. Úgy mint...</p>
<ul>
<li>kód fordítása (make, maven, stb.)</li>
<li>bináris előállítása</li>
<li>statikus kódelemzés futtatása, pl. MISRA, Checkstyle</li>
<li>tesztlefedettség kiszámolását végző szoftver futtatása</li>
<li>riport generálás a feedbackhez a fejlesztőnek, menedzsmentnek, megrendelőnek</li>
<li>stb.</li>
<li>ezek futása lehet...
<ul>
<li>on demand: jellemzően a CI környezetekben kézzel is újra lehet futtatni egy adott <em>job</em>-ot</li>
<li>ütemezett: adott időben ütemezetten fusson (lásd nightly buildek). Pl. egy teljes rendszer teszt, amely akár órákon át is futhat, azt célszerű lehet szó szerint éjjel futtatni, és a reggeli munkakezdésre van egy riport arról, hogy az előző napi változtatások mit törtek el (pl.)</li>
<li>triggerelt: valamilyen esemény hatására fusson le. Pl. egy commit-ra, így minden pusholt commit-ra lefuthatnak a különböző szintű tesztek, statikus kódellenőrzés, stb.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#software-testing" id="software-testing">Software Testing</a></h2>
<ul>
<li><a href="https://www.guru99.com/software-testing-introduction-importance.html">What is Software Testing? Introduction, Definition, Basics &amp; Types </a>
<ul>
<li>Végig lehet lépkedni az egyes fejezeteken, igen jól kimeríti a témát, olyan fejezetei is vannak, amire az előadás nem tért ki.</li>
<li>Több fejezetére specifikusan másutt is hivatkozok</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#test-strategies" id="test-strategies">Test Strategies</a></h2>
<p><img src="https://artoftesters.files.wordpress.com/2014/02/gbt11.jpg" alt="" /></p>
<ul>
<li><a href="https://artoftesters.wordpress.com/2014/02/03/black-vs-white-vs-gray-box-testing/">Black vs White vs Gray Box Testing</a></li>
<li><a href="https://www.guru99.com/white-box-testing.html">What is WHITE Box Testing? Techniques, Example, Types &amp; Tools</a></li>
</ul>
<h2><a class="header" href="#automated-testing" id="automated-testing">Automated Testing</a></h2>
<p><img src="https://artoftesting.com/wp-content/uploads/2019/12/automation-testing-process.jpg" alt="" /></p>
<ul>
<li><a href="https://artoftesting.com/automation-testing">Automation Testing Tutorial</a></li>
<li><a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing">The different types of tests </a></li>
</ul>
<h2><a class="header" href="#integration-testing" id="integration-testing">Integration Testing</a></h2>
<p><a href="https://www.guru99.com/integration-testing.html">Remek összeföglaló a témában</a>, amely kitér a megközelítésekre: Bottom-up, Top-down, Hybrid/Sandwich, Big Bang.</p>
<!--## Feature Testing -->
<h2><a class="header" href="#system-testing" id="system-testing">System Testing</a></h2>
<ul>
<li><a href="https://www.guru99.com/system-testing.html">System testing</a></li>
<li><a href="https://christophergs.com/machine%20learning/2019/03/30/deploying-machine-learning-applications-in-shadow-mode/#what">shadow deploy</a></li>
</ul>
<h3><a class="header" href="#software-in-the-loop-sil" id="software-in-the-loop-sil">Software-in-the-loop (SIL)</a></h3>
<p><img src="https://s3-eu-west-1.amazonaws.com/elasticbeanstalk-eu-west-1-981246043789/wp-content/uploads/2018/09/21142911/Software-in-the-loop.png" alt="" /></p>
<p>forrás: <a href="https://www.intellias.com/three-ways-of-testing-adas-in-autonomous-cars-beyond-a-test-drive/">autonóm autofejlesztés tesztelése</a></p>
<h3><a class="header" href="#hardware-in-the-loop-hil" id="hardware-in-the-loop-hil">Hardware-in-the-loop (HIL)</a></h3>
<p><img src="https://s3-eu-west-1.amazonaws.com/elasticbeanstalk-eu-west-1-981246043789/wp-content/uploads/2018/09/21142901/Hardware-in-the-loop.png" alt="" /></p>
<p>forrás: <a href="https://www.intellias.com/three-ways-of-testing-adas-in-autonomous-cars-beyond-a-test-drive/">autonóm autofejlesztés tesztelése</a></p>
<h2><a class="header" href="#acceptance-testing" id="acceptance-testing">Acceptance Testing</a></h2>
<ul>
<li><a href="http://softwaretestingfundamentals.com/acceptance-testing/">Acceptance Testing</a></li>
<li><a href="https://www.softwaretestinghelp.com/what-is-acceptance-testing/">What is Acceptance Testing</a></li>
</ul>
<h2><a class="header" href="#smart-objectives" id="smart-objectives">SMART Objectives</a></h2>
<p><a href="https://en.wikipedia.org/wiki/SMART_criteria"><img src="http://1.bp.blogspot.com/-GFk16TOMYpg/Vobum9UYB5I/AAAAAAAADJE/W76uhsirM64/s1600/SMART-Goals.jpg" alt="" /></a></p>
<h1><a class="header" href="#continuous-deployment" id="continuous-deployment">Continuous Deployment</a></h1>
<ul>
<li><a href="https://thenewstack.io/deployment-strategies/">Six Strategies for Application Deployment</a></li>
<li><a href="https://featureflags.io/2015/11/03/feature-flag-driven-development-by-justin-launchdarkly/">Feature Flag Driven Development</a>
<ul>
<li>
<blockquote>
<p>This article provides a broad and comprehensive overview of feature flag driven development, from gradual rollouts to A/B testing.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#continuous-delivery" id="continuous-delivery">Continuous Delivery</a></h1>
<ul>
<li><a href="https://www.linkedin.com/pulse/continuous-delivery-vs-traditional-release-model-szczepan-faber">Continuous delivery VS traditional release model</a></li>
</ul>
<h1><a class="header" href="#devops" id="devops">DevOps</a></h1>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Devops-toolchain.svg/1200px-Devops-toolchain.svg.png" width="70%"/>
<ul>
<li><a href="https://theagileadmin.com/what-is-devops/">What Is DevOps?</a></li>
<li><a href="https://thenewstack.io/category/devops/">DevOps</a></li>
</ul>
<h1><a class="header" href="#alkalmazott-eszközök" id="alkalmazott-eszközök">Alkalmazott eszközök</a></h1>
<p>A tárgyhoz használt tényleges eszközök, mondhatjuk, hogy a fentiek (egy részének) gyakorlati alkalmazása.</p>
<h2><a class="header" href="#ci-környzet" id="ci-környzet">CI környzet</a></h2>
<p>Korábban <a href="https://travis-ci.org/">Travis CI</a>, újabban (mióta van) <a href="https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions">GitHub Actions</a>.</p>
<p>A commit(ok) pusholása esemény hatására elindul a build környezet, ez egy Ubuntu linux, amely tartalmazza a Java fejlesztői környezetet (JDK) és a fordítást menedzselő eszközt (Maven). Leklónozza a repót, kiválasztja a kérdéses branch-et, lefordítja a kódot, lefuttatja a teszteket, meghívja a statikus kódelemzőt és a tesztlefedettség elemzőt, az előállt riportokat elküldi az ezt nyilvántartó szolgáltatásoknak. Ha valamennyi teszt sikeres, akkor zöld jelzést ad. (A Jenkins időjárásikonokat használ historikusságot is figyelembe véve: sok egymást követő bukó teszt (viharfelhők) után egy sikeres még nem jelent azonnal napocskát...)</p>
<p><img src="lectures/../images/ci.png" alt="CI környezet" /></p>
<p>A Pull Request-ek elfogadásának feltétele a fordítható kód és a sikeres tesztek, de a statikus kódelemző és a tesztlefedettség elemző visszajelzése is megjelenik (automatizált review formájában). Ugyanilyen automatizált review-nak tekinthető az is, hogy van-e kódütközés.</p>
<p>Ezeken kívül a kollégák manuális review-ja is szükséges (2 approve), lásd review protokol.</p>
<h3><a class="header" href="#példák" id="példák">Példák</a></h3>
<ul>
<li><a href="https://github.com/SzFMV2020-Tavasz/AutomatedCar-A/blob/master/.travis.yml">Nagyon egyszerű konfigurációs állomány Travis-hez</a></li>
<li><a href="https://github.com/SzFMV2020-Tavasz/AutomatedCar-A/blob/master/.github/workflows/maven.yml">Aktuális GitHub Actions konfiguráció</a></li>
</ul>
<h2><a class="header" href="#statikus-kódelemzés" id="statikus-kódelemzés">Statikus kódelemzés</a></h2>
<p>A statikus kódelemzést Java nyelvhez a Checkstyle végzetre, C#-hoz a StyleCop, ez lokálisan (lásd fejlesztőeszközök fejezet) is működik, a változások követéséhez és mindenféle riport generálásához (első sorban a Pull Requestekhez) a <a href="https://www.codefactor.io/">CoceFactor.io</a> van bekötve. Ez össze van linkelve a GitHubbal repóval, a commit triggerre saját környezetben kicsekkolja az aktuális branchet, lefuttatja a Checkstyle-t (és adott esetben más elemzőket is), majd elkészíti a riportokat.</p>
<h2><a class="header" href="#tesztlefedettség" id="tesztlefedettség">Tesztlefedettség</a></h2>
<p>A Java kódunk tesztekkel való lefedettségét Java nyelvhez a JaCoCo (Java Code Coverage) nevű szoftver számolta ki, C#-hoz a Coverlet. Szintén működik lokálisan is (lásd fejlesztőeszközök fejezet), a CodeFactorhoz hasonló online riportgeneráló amit a repónkhoz beállítottam az a <a href="https://codecov.io/">CodeCov</a>. Az előbbivel analóg módon működik.</p>
<h2><a class="header" href="#stale-bot" id="stale-bot">Stale bot</a></h2>
<p>A <a href="https://probot.github.io/apps/stale/">stale bot</a> funkciója, hogy a magára hagyott hibajegyeket (issue) megjelöli „megrekedt” (stale) állapottal (címkével), ha adott ideig (nálunk 1 hét) nem volt vele kapcsolatos aktivitás. Ez alól kivételt képeznek a „user story” címkéjű issue-k.</p>
<p>A konfigurációja a repó <a href="https://github.com/SzFMV2020-Tavasz/AutomatedCar-A/blob/master/.github/stale.yml"><code>.github/stale.yaml</code></a> fájljában található.</p>
<h1><a class="header" href="#software-architecture" id="software-architecture">Software Architecture</a></h1>
<!-- toc -->
<h2><a class="header" href="#growing-software" id="growing-software">Growing software</a></h2>
<p>Linux kernel - number of lines of code (forrás: <a href="https://en.wikipedia.org/wiki/Linux_kernel">Wikipedia</a>)</p>
<p><img src="lectures/../images/linux_kernel_loc.png" alt="" title="Linux kernel - number of lines of code" /></p>
<ul>
<li><a href="https://www.linux.com/news/why-linuxs-biggest-ever-kernel-release-is-really-no-big-deal/">Why Linux’s biggest ever kernel release is really no big deal</a>
<ul>
<li>Linux 5.8 features over 14,000 non-merge commits, some 800,000 new lines of code, and added around a hundred new contributors.</li>
</ul>
</li>
</ul>
<p><img src="https://s.yimg.com/ny/api/res/1.2/up437vRgY_hH6IXyJKtnMA--%7EA/YXBwaWQ9aGlnaGxhbmRlcjtzbT0xO3c9NjUwO2g9NjAx/http://globalfinance.zenfs.com/en_us/Finance/US_AFTP_SILICONALLEY_H_LIVE/Googles_services_are_powered_by-af07bc22a8b413a9049fd5c7514120be" alt="" /></p>
<ul>
<li><a href="https://www.informationisbeautiful.net/visualizations/million-lines-of-code/">Teljesebb összehasonlítás</a></li>
</ul>
<p><img src="https://media-exp1.licdn.com/dms/image/C5612AQH7gNeeKaTNmw/article-inline_image-shrink_1000_1488/0?e=1603929600&amp;v=beta&amp;t=ATCHNcp6I4KDurgt0Iy_zaM3Kt0tdgDa5FUHfuDH2eI" alt="" /></p>
<ul>
<li><a href="https://www.linkedin.com/pulse/20140626152045-3625632-car-software-100m-lines-of-code-and-counting">Az autóipar tekintetében</a></li>
</ul>
<h3><a class="header" href="#the-more-the-better" id="the-more-the-better">The more, the better?</a></h3>
<blockquote>
<p>if we wish to count lines of code, we should not regard them as &quot;lines produced&quot; but as &quot;lines spent&quot;</p>
<p>E.W. Dijkstra <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html">EWD 1036</a></p>
</blockquote>
<hr />
<blockquote>
<p>Every line of code written comes at a price: maintenance. To avoid paying for a lot of code, we build reusable software. The problem with code re-use is that it gets in the way of changing your mind later on.</p>
<p>tef - <a href="https://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to">Write code that is easy to delete, not easy to extend</a></p>
</blockquote>
<h2><a class="header" href="#complex-software" id="complex-software">Complex Software</a></h2>
<p><img src="https://miro.medium.com/max/1248/0*hZLEb6SYbTH8n3l8.png" alt="" /></p>
<ul>
<li><a href="https://www.simplethread.com/software-complexity-killing-us/">Software Complexity Is Killing Us</a></li>
<li><a href="https://carlalexander.ca/what-is-software-complexity/">What is software complexity and how can you manage it?</a></li>
</ul>
<h3><a class="header" href="#how-to-measure---cyclomatic-complexity" id="how-to-measure---cyclomatic-complexity">How to measure? - Cyclomatic complexity</a></h3>
<blockquote>
<p><em>Cyclomatic complexity</em> measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows:</p>
<p>cyclomatic complexity = the number of edges - the number of nodes + 1</p>
<p>where a node represents a logic branch point and an edge represents a line between nodes.</p>
<p>The rule reports a violation when the cyclomatic complexity is more than 25.</p>
<p><a href="https://docs.microsoft.com/hu-hu/visualstudio/code-quality/ca1502-avoid-excessive-complexity?view=vs-2015&amp;redirectedfrom=MSDN">CA1502: Avoid excessive complexity</a></p>
</blockquote>
<!-- ![](https://carlalexander.ca/app/uploads/2018/02/control-graph-paths.png) -->
<h3><a class="header" href="#issues-with-cyclomatic-complexity" id="issues-with-cyclomatic-complexity">Issues with cyclomatic complexity</a></h3>
<ul>
<li>Not every statement is equal
<ul>
<li><code>if</code>, <code>while</code>, <code>for</code> and <code>case</code> statements considered as identical</li>
</ul>
</li>
<li>Nesting
<ul>
<li>it doesn’t account for nesting</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#npath-complexity" id="npath-complexity">NPATH complexity</a></h3>
<blockquote>
<p>The NPath complexity of a method is the number of acyclic execution paths through that method. A threshold of 200 is generally considered the point where measures should be taken to reduce complexity.</p>
<p><a href="http://phpmd.org/rules/codesize.html#npathcomplexity">NPathComplexity</a></p>
</blockquote>
<blockquote>
<p>Consider writing a unit test and you have a function with an NPath complexity of 16. This means that if you need want 100% code coverage you need to test for 16 possible outcomes and that would end up in pretty messy tests.</p>
<p>Niklas Modess - <a href="https://modess.io/npath-complexity-cyclomatic-complexity-explained/">NPath complexity and cyclomatic complexity explained</a></p>
</blockquote>
<!-- ```java
//Cyclomatic Complexity = 3. Npath Complexity = 4.
public int compare(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}
```

Above code can be rewritten as below:

```java
//Cyclomatic Complexity = 2. Npath Complexity = 2.
public int compare(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}
``` -->
<ul>
<li><a href="https://audiolion.github.io/python/2016/10/17/reducing-cyclomatic-complexity.html">Reducing Cyclomatic Complexity with Python</a></li>
<li><a href="https://modess.io/npath-complexity-cyclomatic-complexity-explained/">NPath complexity and cyclomatic complexity explained</a></li>
</ul>
<h3><a class="header" href="#complex-vs-complicated" id="complex-vs-complicated">Complex vs. complicated</a></h3>
<p>Michael Bykovski: <a href="https://medium.com/better-programming/simple-vs-complicated-vs-complex-vs-chaos-737b5964849d">Simple vs. Complicated vs. Complex vs. Chaotic</a></p>
<h3><a class="header" href="#complexity-accidental-vs-essential" id="complexity-accidental-vs-essential">Complexity: Accidental vs. Essential</a></h3>
<blockquote>
<p><strong>Accidental Complexity</strong> is something that can be simplified by a new idea, design, technique, procedure or approach. <strong>Essential Complexity</strong> is something that can't be simpler or something that loses value when it becomes simpler. Identifying the difference between accidental and essential complexity is a fundamental design technique.</p>
<p>John Spacey - <a href="https://simplicable.com/new/accidental-complexity-vs-essential-complexity">Complexity: Accidental vs. Essential</a></p>
</blockquote>
<h2><a class="header" href="#what-is-software-architecture" id="what-is-software-architecture">What is Software Architecture</a></h2>
<blockquote>
<p>&quot;Architecture&quot; is a term that lots of people try to define, with little agreement. There are two common elements: One is the highest-level breakdown of a system into its parts; the other, decisions that are hard to change.</p>
<p>Martin Fowler - Patterns of Enterprise Application Architecture</p>
</blockquote>
<blockquote>
<p>All architecture is design but not all design is architecture. Architecture represents the significant design decisions that shape a system, where significant is measured by cost of change.</p>
<p>Grady Booch</p>
</blockquote>
<ul>
<li><a href="https://www.developerfusion.com/article/84899/what-is-software-architecture/">What is Software Architecture?</a></li>
<li><a href="https://medium.com/docplanner-tech/the-goals-of-software-architecture-a3b0a0edeb0b">The goals of Software Architecture</a></li>
</ul>
<h2><a class="header" href="#miért-kell-ez" id="miért-kell-ez">Miért kell ez?</a></h2>
<blockquote>
<p>Architecture is the decisions that you wish you could get right early in a project </p>
<p>-- Ralph Johnson</p>
</blockquote>
<ul>
<li>https://gbksoft.com/blog/why-you-need-a-software-architect-for-your-project/</li>
<li>https://www.martinfowler.com/articles/designDead.html#SoIsDesignDead</li>
<li>https://www.codeproject.com/Articles/1064240/Introduction-to-Software-Architecture</li>
</ul>
<h2><a class="header" href="#hogyan-lesz-egy-ilyenünk" id="hogyan-lesz-egy-ilyenünk">Hogyan lesz egy ilyenünk?</a></h2>
<!-- goals requiremets contstraint -->
<ul>
<li><a href="https://medium.com/@mbue/practical-tips-on-software-architecture-design-part-one-1c6bb0167157">Practical Tips on Software Architecture Design, Part One</a></li>
<li><a href="https://medium.com/@mbue/practical-tips-on-software-architecture-design-part-two-37c2b61d7b6d">Practical Tips on Software Architecture Design, Part Two</a></li>
</ul>
<h3><a class="header" href="#architecture-decision-records" id="architecture-decision-records">Architecture decision records</a></h3>
<ul>
<li><a href="https://github.blog/2020-08-13-why-write-adrs/">Why Write ADRs</a></li>
<li><a href="https://github.com/joelparkerhenderson/architecture_decision_record">néhány ADR sablon</a></li>
</ul>
<p>Alább látható a Michael Nygard féle sablon: <a href="https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions">Documenting Architecture Decisions</a></p>
<pre><code class="language-markdown"># ADR template by Michael Nygard

This is the template in [Documenting architecture decisions - Michael Nygard](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions).
You can use [adr-tools](https://github.com/npryce/adr-tools) for managing the ADR files.

In each ADR file, write these sections:

# Title

## Status

What is the status, such as proposed, accepted, rejected, deprecated, superseded, etc.?

## Context

What is the issue that we're seeing that is motivating this decision or change?

## Decision

What is the change that we're proposing and/or doing?

## Consequences

What becomes easier or more difficult to do because of this change?
</code></pre>
<h2><a class="header" href="#design-principles" id="design-principles">Design Principles</a></h2>
<p><img src="https://user-images.githubusercontent.com/6892666/65833569-bb34fc00-e29f-11e9-8516-79cbd9f8f07b.png" alt="" /></p>
<ul>
<li><a href="https://khalilstemmler.com/articles/software-design-architecture/full-stack-software-design/">How to Learn Software Design and Architecture</a>
<ul>
<li>fenti kép forrása</li>
</ul>
</li>
<li><a href="lectures/./legacy_code.html#SOLID">SOLID</a></li>
<li><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>
<ul>
<li>&quot;You aren't gonna need it&quot;</li>
<li>
<blockquote>
<p>Always implement things when you actually need them, never when you just foresee that you need them.</p>
<p>Ron Jeffries </p>
</blockquote>
</li>
<li>TDD</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#4c-complete-compliant-clear-concise" id="4c-complete-compliant-clear-concise">4C: Complete, Compliant, Clear, Concise</a></h3>
<ul>
<li><a href="https://www.govwebworks.com/2017/05/01/four-cs-for-flawless-agile-business-requirements/">Four Cs for Flawless Agile Business Requirements</a></li>
<li>https://www.mojotech.com/blog/the-4cs-a-code-review-mnemonic/</li>
</ul>
<!-- ###

if two developer should think of the same answer for theri separete question, independently, it belongs in architecture

requirement engineering vs. software architecture
problématér beli definíció vs. probléma és megoldás között lépked, egyre alacsonyabb szintű problémát generálva oldja meg a magas szintűt

risk management: elemezzük a kockázatokat, kitaláljuk, hogy hogyan kezelnénk, majd minden módosítsnál felülértékeljük.

min 2 alternatíve leírva és átgondolva, hogy miért nem azokat választottuk
miért kérdésre a válaszra

https://sceweb.uhcl.edu/helm/RationalUnifiedProcess/process/modguide/md_sad.htm#Architectural%20Goals%20and%20Constraints -->
<h3><a class="header" href="#a-hrefhttpsenwikipediaorgwikirob_pike-data-wiki-langen-data-wiki-titlerob-pikerob-pikeas-5-rules-of-programming" id="a-hrefhttpsenwikipediaorgwikirob_pike-data-wiki-langen-data-wiki-titlerob-pikerob-pikeas-5-rules-of-programming"><a href="https://en.wikipedia.org/wiki/Rob_Pike" data-wiki-lang="en" data-wiki-title="Rob Pike">Rob Pike</a>'s 5 Rules of Programming</a></h3>
<ol>
<li>You can't tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don't try to second guess and put in a speed hack until you've proven that's where the bottleneck is.</li>
<li>Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest.</li>
<li>Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don't get fancy. (Even if n does get big, use Rule 2 first.)</li>
<li>Fancy algorithms are buggier than simple ones, and they're much harder to implement. Use simple algorithms as well as simple data structures.</li>
<li>Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</li>
</ol>
<p>Pike's rules 1 and 2 restate Tony Hoare's famous maxim &quot;Premature optimization is the root of all evil.&quot; Ken Thompson rephrased Pike's rules 3 and 4 as &quot;When in doubt, use brute force.&quot;. Rules 3 and 4 are instances of the design philosophy KISS. Rule 5 was previously stated by Fred Brooks in The Mythical Man-Month. Rule 5 is often shortened to &quot;write stupid code that uses smart objects&quot;.</p>
<p><a href="http://users.ece.utexas.edu/%7Eadnan/pike.html">forrás</a></p>
<h3><a class="header" href="#zen-of-pythonsup-classfootnote-referencea-href11asup" id="zen-of-pythonsup-classfootnote-referencea-href11asup">Zen of Python<sup class="footnote-reference"><a href="#1">1</a></sup></a></h3>
<blockquote>
<p>The Zen of Python is a collection of 19 &quot;guiding principles&quot; for writing computer programs that influence the design of the Python programming language. <sup class="footnote-reference"><a href="#2">2</a></sup></p>
</blockquote>
<ol>
<li>Beautiful is better than ugly.</li>
<li>Explicit is better than implicit.</li>
<li>Simple is better than complex.</li>
<li>Complex is better than complicated.</li>
<li>Flat is better than nested.</li>
<li>Sparse is better than dense.</li>
<li>Readability counts.</li>
<li>Special cases aren't special enough to break the rules.</li>
<li>Although practicality beats purity.</li>
<li>Errors should never pass silently.</li>
<li>Unless explicitly silenced.</li>
<li>In the face of ambiguity, refuse the temptation to guess.</li>
<li>There should be one-- and preferably only one --obvious way to do it.</li>
<li>Although that way may not be obvious at first unless you're Dutch.</li>
<li>Now is better than never.</li>
<li>Although never is often better than <em>right</em> now.</li>
<li>If the implementation is hard to explain, it's a bad idea.</li>
<li>If the implementation is easy to explain, it may be a good idea.</li>
<li>Namespaces are one honking great idea -- let's do more of those!</li>
</ol>
<ul>
<li><sup class="footnote-reference"><a href="#1">1</a></sup> <a href="https://www.python.org/dev/peps/pep-0020/">PEP 20</a></li>
<li><sup class="footnote-reference"><a href="#2">2</a></sup> <a href="https://en.wikipedia.org/wiki/Zen_of_Python">wiki://Zen of Python</a></li>
</ul>
<h3><a class="header" href="#the-23-gang-of-four-design-patterns" id="the-23-gang-of-four-design-patterns">The 23 Gang of Four Design Patterns</a></h3>
<p><a href="http://www.blackwasp.co.uk/GofPatterns.aspx">Teljes összefoglaló</a>, ahol mindegyikhez van magyarázat, UML diagram és C# kód.</p>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/AbstractFactory.aspx">Abstract Factory</a></td><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Facade.aspx">Facade</a></td><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Proxy.aspx">Proxy</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Adapter.aspx">Adapter</a></td><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/FactoryMethod.aspx">Factory Method</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Observer.aspx">Observer</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Bridge.aspx">Bridge</a></td><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Flyweight.aspx">Flyweight</a></td><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Singleton.aspx">Singleton</a></td></tr>
<tr><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Builder.aspx">Builder</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Interpreter.aspx">Interpreter</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/State.aspx">State</a></td></tr>
<tr><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/ChainOfResponsibility.aspx">Chain of Responsibility</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Iterator.aspx">Iterator</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Strategy.aspx">Strategy</a></td></tr>
<tr><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Command.aspx">Command</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Mediator.aspx">Mediator</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/TemplateMethod.aspx">Template Method</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Composite.aspx">Composite</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Memento.aspx">Memento</a></td><td><img src="lectures/../images/b.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Visitor.aspx">Visitor</a></td></tr>
<tr><td><img src="lectures/../images/s.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Decorator.aspx">Decorator</a></td><td><img src="lectures/../images/c.png" alt="" /></td><td><a href="http://www.blackwasp.co.uk/Prototype.aspx">Prototype</a></td><td></td><td></td></tr>
</tbody></table>
<!-- ![](../images/design_patterns.png "The Gang of Four Design Patterns") -->
<p><img src="lectures/../images/design_patterns_legend.png" alt="" /></p>
<h3><a class="header" href="#topologies" id="topologies">Topologies</a></h3>
<p><a href="https://www.codeproject.com/Articles/1064240/Introduction-to-Software-Architecture">Introduction to Software Architecture</a></p>
<h4><a class="header" href="#layered-architechture" id="layered-architechture">Layered Architechture</a></h4>
<p><img src="http://1.bp.blogspot.com/-TbA8p6DWYJc/Uc0zYwSG_iI/AAAAAAAAAag/cPytbL6oeM4/s800/layered.png" alt="" /></p>
<ul>
<li><a href="http://serena-yeoh.blogspot.com/2013/06/layered-architecture-for-net.html">Layered Architecture: Introduction</a></li>
<li><a href="http://serena-yeoh.blogspot.com/2014/01/layered-architecture-components.html">Layered Architecture: Component Interactions</a></li>
</ul>
<h4><a class="header" href="#message-bus-architecture" id="message-bus-architecture">Message Bus Architecture</a></h4>
<p><img src="https://www.codeproject.com/KB/architecture/1064240/message-bus.gif" alt="" /></p>
<h4><a class="header" href="#server-client-architecture" id="server-client-architecture">Server-Client Architecture</a></h4>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/1200px-Client-server-model.svg.png" alt="" /></p>
<h2><a class="header" href="#c4-model" id="c4-model">C4 model</a></h2>
<ul>
<li><a href="https://c4model.com/">The C4 model for visualising software architecture</a>
<ul>
<li>Context, Containers, Components and Code</li>
</ul>
</li>
<li><a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></li>
</ul>
<h3><a class="header" href="#level-1-system-context-diagram" id="level-1-system-context-diagram">Level 1: System Context diagram</a></h3>
<blockquote>
<p>Shows the software system you are building and how it fits into the world in terms of the people who use it and the other software systems it interacts with.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<h3><a class="header" href="#level-2-container-diagram" id="level-2-container-diagram">Level 2: Container diagram</a></h3>
<blockquote>
<p>Zooms into the software system, and shows the containers (applications, data stores, microservices, etc.) that make up that software system. Technology decisions are also a key part of this diagram.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<h3><a class="header" href="#level-3-component-diagram" id="level-3-component-diagram">Level 3: Component diagram</a></h3>
<blockquote>
<p>Zooms into an individual container to show the components inside it. These components should map to real abstractions (e.g., a grouping of code) in your codebase.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<h3><a class="header" href="#level-4-code" id="level-4-code">Level 4: Code</a></h3>
<blockquote>
<p>Finally, if you really want or need to, you can zoom into an individual component to show how that component is implemented.</p>
<p>Simon Brown - <a href="https://www.infoq.com/articles/C4-architecture-model/">The C4 Model for Software Architecture</a></p>
</blockquote>
<p><img src="https://c4model.com/img/c4-overview.png" alt="" /></p>
<h2><a class="header" href="#versioning" id="versioning">Versioning</a></h2>
<h3><a class="header" href="#semantic-versioning" id="semantic-versioning">Semantic Versioning</a></h3>
<p><img src="https://jontejada.com/blog/assets/semver02.png" alt="" /></p>
<ul>
<li><a href="https://semver.org">website</a></li>
<li><a href="https://snarky.ca/why-i-dont-like-semver/">Why I don't like SemVer anymore</a>
<ul>
<li>blogposzt az árnyoldalairól</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#calendar-versioning" id="calendar-versioning">Calendar Versioning</a></h3>
<ul>
<li>&quot;<em>CalVer</em> is a versioning convention based on your project's release calendar, instead of arbitrary numbers.&quot;</li>
<li>YYYY.MINOR.MICRO</li>
<li><a href="https://calver.org">website</a></li>
</ul>
<h3><a class="header" href="#zerover-0-based-versioning" id="zerover-0-based-versioning">ZeroVer: 0-based Versioning</a></h3>
<ul>
<li>&quot;Your software's major version should never exceed the first and most important number in computing: zero.&quot;</li>
<li>e.g.: <strong>0.4.1</strong></li>
<li><a href="https://0ver.org">website</a></li>
</ul>
<!-- godbolt.org -->
<!-- https://nerds-den.com/how-to-design-software-that-you-can-be-proud-of/ --><h1><a class="header" href="#mindmap-1" id="mindmap-1">MindMap</a></h1>
<p>Összefoglaláshoz, gyors áttekintéshez használható, az előadásanyagot többé-kevésbé lefedő <em>mindmap</em>. Egérgörgővel nagyítható/távolítható és canvas-on belül szabadon mozgatható.</p>
<p><svg id="markmap-target" style="width: 100%; height: 75vh;"></svg></p>
<div id="markmap-source" hidden>
<pre><code># SzFMV


## Agile

- SCRUM
    - Roles
        - Scrum Master
            - Developer Representative
            - Impediment handler
            - Facilitator
            - Ensures calm and uninterrupted working
        - Product Owner
            - Customer Representative
            - Creates PB
            - Prioritizese PB
        - Developer
        - Team
            - Self-organizing
            - Cross-functional
    - Epic
        - User Story
            - Task
    - Events
        - Sprint Planning
        - Daily Standup
            - 3 questions
            - TimeBox
            - Always on the same time and at the same place
            - Standing up
        - Backlog Grooming
            - Refinement of User Story DoD
                - SMART goals
            - Effort estimation
        - Retrospective
        - Demo
        - Sprint Review
    - Artifacts
        - Sprint Backlog
        - Product Backlog
        - Sprint Goal
        - Definition of Done
        - Burndown Chart
        - Board
- Kanban
    - Continuous (not iterative)
    - No roles, no events
    - Board necessary - pick top right task
- Culture / Mindset
    - Agile Manifesto
        - Agile Principles
    - Iterative
    - Change handling
- Waterfall / V-Model
- Business Value

## Clean Code

- Communication
    - understanding what it does
- Style Guideline
    - Naming
        - Variables
            - Why?
    - Function
        - Short functions
        - Does one thing
    - Scope
        - Functions - one scope
        - Variables - Scope
- Self Documenting - No comments
- Code Smells
    - Long function
    - Too many parameters
    - God Class
    - Boolean parameter
    - Magic number
    - Circular dependency
    - Too complex (cyclomatic complexity)
- Refactoring
    - Boy scout mantra

## Review

- What?
    - Requirement
    - Architecture
    - Design
    - Work events
    - Code
    - Everything
    - Work product - not the developer
- Why?
    - Avoid errors
- Who?
    - Anyone who's competent in the topic
- Levels
    - Formal
        - Traceable
        - Documented
        - Rule Based
        - Type
            - Walkthrough
            - Inspection
            - Technical
        - Dedicated roles
            - Minute taker
            - Expert
            - Moderator
    - Informal
        - Over the shoulder
        - Pair Programming
- Finding
    - Severe / Major
        - must be changed
    - Suggestion / Minor
        - may be changed
    - Question
        - WTF?
    - Action
        - Ignore
        - Fix
        - Answer
        - Explain
        - Promote
- Debug Ducky

## Legacy Code

- SOLID
    - Design Principles
        - **S**ingle Responsibility
        - **O**pen-closed
        - **L**iskov's Substitution
        - **I**nterface Segregation
        - **D**ependency Inversion
- Code without tests
    - Gets better or worse?
- Sprout
    - method
    - class
- Avoid, rewrite
- Legacy Code Dilemma
    - Can't change the code without adding tests
    - Have to change the code to add tests
- Seams
    - Change the behaviour without changing the code
    - Object Seam
    - Linker Seam
    - Preprocessor
- Reason of change
    - Performance
        - Optimization
    - Functionality
        - Bugfix
        - New Feature
    - Structure
        - Refactoring
- Overestimation
    - Get the oppurtunity to reverse legacy

## Test Driven Development

- Software Unit
    - Function
    - Class
    - Module
- Test Suite
    - Test Case
        - Test
            - Single Assert
            - Logical, not semantical
    - Fast as hell
        - ms fast
        - Effectiveness
        - Flow
- AAA(A) Rule
    - Arrange
        - Set up system under test
        - Dependencies
        - Mocking
            - Database
            - Hardware
            - Mock object
                - Dummy
                - Stub
                - Fake
                - Mock
                - Spy
    - Act
        - Do the needful
    - Assert
        - Expected vs. Actual
        - Single Assert
    - (Annihilate)
        - Free resource
- Red -&gt; Green -&gt; Refactor
    - Write a failing test
    - Make the test pass
        - Code Golf
        - As little code as possible
    - Refactor
- Fastest feedback
- Safety net
- Getting stuck
    - Transformation Priorities
- Done
    - Potato mantra

## Continuous Integration

- Interrupt
    - Loosing hours of work
- Workload reduction
- Work automation
- Structure
    - Version Tracking
        - Best Practices
            - Syncronize often
            - Small changes
            - Merge often
            - Independent tasks
    - Continuous Integration Server
        - Automatic Build
            - Jobs / Pipelines
        - Automatic Integration
        - Automatic Test
        - Automatic Release
        - Automatic Deploy
    - Feedback to stakeholders
- Trigger
    - Nightly Build
        - time based
    - Trigger
        - Push
        - Pull Request
    - Manual
- DevOps
    - Developers
    - Operations
- Integration Strategy
    - Bottom-Up
    - Top-Down
    - Big-Bang
    - Ricky-Hardest
- Levels
    - Unit
    - Integration
    - Feature
    - System
    - Acceptance
    - Manual

## Architecture
</code></pre>
</div>
<h1><a class="header" href="#szoftver-leírása" id="szoftver-leírása">Szoftver leírása</a></h1>
<p>The program simulates the behavior of a passenger vehicle on the public road, equipped with driver assistance functions.</p>
<p>Equipped driver assistance functions are Parking Assist, Adaptive Cruise Control with Automated Emergency Braking and Lane Keeping Assistance with Traffic Sign Recognition, based on Ultra Sonic, Radar and Video sensors, respectively.</p>
<p>The inputs are categorized into two separate groups: user input, and configuration.</p>
<p>User input consists of the following elements:</p>
<ul>
<li>Throttle button - gradually increasing while pressed, on a 1s duration from 0-&gt;100%, if not pressed, returns to idle</li>
<li>Brake  button - gradually increasing while pressed, on a 0.5s duration from 0-&gt;100%, if not pressed, returns to idle</li>
<li>Gear Shift - Automated, P/R/N/D available for choosing with a rotary button</li>
<li>Steering Buttons - left, right, gradually increasing while pressed on a 1s duration from 0-&gt;100%, in idle returns to straight</li>
<li>Driver Assistance Function Main Switches - On/Off, flip switch, changes state on press</li>
<li>ACC: Set/Resume/Plus/Minus/Time Gap switches, activating the function, changing the chosen reference speed, changing the chosen distance to the target vehicle, respectively</li>
<li>PA: Indicators to activate parking spot search, confirmation button to trigger automated parking maneuver</li>
</ul>
<p>Configuration input consist of the following elements:</p>
<ul>
<li>Description of world in an XML file, in a predefined language</li>
<li>&quot;Tiles&quot; - building blocks of the simulated world, such as roads, trees, people, vehicles, buildings, etc.</li>
<li>Position and behavior of non-player vehicles and characters</li>
<li>Position of the player vehicle</li>
</ul>
<p>The system processes the input configuration, builds a world from the provided elements after processing the content of the XML file, creating a coordinate system and defining the distances, sizes and positions of the objects in that, places the non-player vehicles and the player in the world, and cyclically updates their position, interrupting or replacing the driver input with the calculated actuation requests from the Driver Assistance systems, whenever applicable. The output consists of two parts: first, the world with all its objects, displayed through a camera view, which centers on the player, and follows its movements, second the feedback about the current state of the vehicle, including the following data:</p>
<ul>
<li>Current speed</li>
<li>Current gas, brake pedal position</li>
<li>Current steering wheel angle</li>
<li>Current gear</li>
<li>Indicator status</li>
<li>ACC: Set Speed, Time Gap level, Object detected (boolean), main status(on/off/controlling)</li>
<li>AEB: on/off status, visual warning signal (Yellow: probable collision, Red: automated braking active)</li>
<li>Parking assist: available(yellow),searching for place(blinking yellow), spot found(green), parking (blinking green), off (no signal)</li>
<li>LKA/TSR: On/Off, detected speed limit, detected warning sign, controlling steering(green), lane marking not available(yellow)</li>
</ul>
<p>The driver assistance systems apply actuation requests to the steering, drivetrain(engine, transmission) or both, of the ego vehicle. Said subsystems decide if the actuation request of the player or the driver assistance system shall be executed. The actuation request is calculated from the information detectable by the sensor the DA systems depend on. The Video, Radar and Ultrasonic sensors have specified Fields of View, and view distance, detect a different subset of objects. From the provided object list - simulating the real world hardware detection of radar wave reflection, image processing, ultrasonic reflection - the &quot;software&quot; components evaluate the control relevant subset, and if the conditions are fulfilled (i.e. function activated and driving in lane, object in ego lane in front of vehicle, relative speed negative, distance reducing as time passes by) the function requests actuation (in the above example, requests speed reduction from the drivetrain).</p>
<p>The system decides between the concurrent drivetrain requests based on comfort and safety aspects. The system shall handle and detect collisions between the objects of the world. The simulation is approximating the real world physics, to provide a satisfying driving experience for the player, and an appropriate demonstration of the work of the driver assistance systems. On demand, the field of view of the sensors, and the detected control objects may be marked on the display for debug or demonstration.</p>
<h1><a class="header" href="#sprintek" id="sprintek">Sprintek</a></h1>
<p>A félév során minden csapat 3 sprintet teljesít, minden sprintre egy-egy user story-t kap. 4 csapat esetén így a teljes elkészítendő szoftver 12 részre van bontva. A csapatok feladata a user story-k megértése, felbontása egyhuzamban elvégezhető feladatokra (task), ezekhez felelőst és határidőt rendelve.</p>
<p>Szintén a csapatok feladat a feladatok közötti függőségek azonosítása és az erőforrások (idő, fejlesztő) oly módon történő beosztása, hogy a határidőre minden elkészüljön. Az egyes user story-k között nem csak sprinteken átívelő függőségek lehetnek, hanem sprinten belüliek is. Ilyen esetben az érintett csapattal egyeztetve kell az egyes (rész)feladatok prioritásait meghatározni.</p>
<p>A user story-k függőségi gráfja alább látható, sprintenként színezve.</p>
<p><img src="images/dependencies_4_team.png" alt="" /></p>
<p>A következő ábrán pedig a user story-k a felelős csapatok alapján van színezve.</p>
<p><img src="images/team_user_stories.png" alt="" /></p>
<h1><a class="header" href="#1-sprint" id="1-sprint">1. Sprint</a></h1>
<h2><a class="header" href="#human-machine-interface-hmi-műszerfal-irányítás" id="human-machine-interface-hmi-műszerfal-irányítás">Human Machine Interface (HMI): Műszerfal, irányítás</a></h2>
<p>A <em>HMI</em> modul felelőssége a vezérelt autó (egocar) kezelőszerveinek és visszejelzőinek megvalósítása. Bemeneti jelként kezelnie kell tehát a billentyűeseményeket, le kell őket fordítani az autó vezérlőszerveire, valamint a műszerfalon meg kell jeleníteni az egocar állapotát leíró értékeket.</p>
<p>A modul kihívása a „bináris állapotú” billentyűesemények „fokozatossá tétele”. A gáz- és fékpedál nyomvatartásának ideét kell leképezni a pedál lenyomás mértékére és egy adott idő alatt kell ennek 100%-ra jutnia. A hajtáslánc a pedálok lenyomásának mértékét használja majd a gyorsítás - és úgy általában az elmozdulás mértékének - meghatározásához.
A pedálokhoz hasonlóan a kormány elfordítása sem bináris, ugyanúgy a billentyűlenyomás idejének felhasználásával kell számolni. Ezek skáláját a hajtásláncért modullal egyeztetve kell meghatározni (pl. pedáls lenyomás 0-100 között).</p>
<p>A szimulált autó automata váltóval rendelkezik, így a váltó <em>P</em>, <em>R</em>, <em>N</em>, <em>D</em> állapotatit is is közvetíteni kell a hajtáslánc felé.</p>
<p>A műszerfalnak az alábbi vázlathoz hasonlóan kell felépülnie. A programablak bal oldalán a virtuális világ egy szeletét látjuk ezért felel, a vizualizációs modul. A jobb oldalon a műszerfal található. A műszerfalon nincsenek vezérlőelemek, csak megjelenítés. Az összes kapcsoló a billentyűzettel állítható, a grafikus elemeknek nem kell pl. egérrel kapcsolhatónak lenniük.</p>
<p><img src="images/gui_plan_dashboard.png" alt="gui_plan" /></p>
<p>A fordulatszám és a sebesség legyen egy analóg órával reprezentálva; a kormány elforgazás, a gáz- és fékpedál állása progressbar-okkal szemléltethető. Az irányjelző visszajelzője és a vezetéstámogató funkciók visszajelzői lámpaszerűek, a sebességváltó állása, és a debug értékek pl. kocsi pozíciója (x, y koordináta) lehet szöveges.</p>
<p>Az utoljára látott tábla -csak úgy mint a többi vezetéstámogató funkció- ugyan csak a 3. sprintben lesz kihasználva, de már most biztosítani kell a visszejelzését. A buszon közölt „utoljára látott tábla” képét ki kell tudni rajzolni (a képek rendelkezésre állnak). Legyen elkülönítve a nincs tábla eset is.</p>
<h3><a class="header" href="#definition-of-done" id="definition-of-done">Definition of Done</a></h3>
<ul>
<li>a fék- és gázpedál állapota szabályozható</li>
<li>fék- és gázpedál valamint a kormány sem binárisan működik, a billentyű nyomva tartás idejétől függ az input intenzitása</li>
<li>fék- és gázpedál valamint a kormány is fokozatosan áll vissza alaphelyzetbe a billentyű felengedésével</li>
<li>az automata váltó 4 állapota szabályozható
<ul>
<li>szekvenciális váltóról lévén szó, sorban állíthatók a fokozatok: P(ark), R(everse), N(eutral), D(rive)</li>
<li>alaphelyzet: P, „felváltás” után R, majd N, majd D. „Leváltás” ugyanez visszafele.</li>
</ul>
</li>
<li>ACC: Állítható céltávolság (T jelű gombbal, körkörösen 0.8/1.0/1.2/1.4 másodperc)</li>
<li>ACC: Állítható célsebesség (+/- gombbal, 30-160, 10-es lépésközzel)</li>
<li>Lane Keeping bekapcsolás</li>
<li>Parkig pilot bekapcsolás</li>
<li>irányjelző (jobb, bal) kapcsolható</li>
<li>egyszerre több billentyű is használható
<ul>
<li>kanyarodni és gázt adni/fékezni minimum kell tudni egyszerre</li>
</ul>
</li>
<li>Megjelenik a fordulatszám mint „analóg óra”</li>
<li>Megjelenik a sebesség mint „analóg óra”</li>
<li>Megjelenik a kormányállás</li>
<li>Megjelenik a gáz, fék állapota (progressbar)</li>
<li>Megjelenik a sebességváltó állása (szövegesen)</li>
<li>Irányjelző visszajelző (egy-egy nyíl kirajzolva)</li>
<li>Kocsi pozíció megjelenítése (x, y koordináta debug céllal, szövegesen)</li>
<li>Vezetéstámogató funkciók visszajelzései
<ul>
<li>ACC idő és sebesség limit</li>
<li>parking pilot és a lane keeping rendszerek állapot visszajelzése</li>
</ul>
</li>
<li>az utolsó látott tábla megjelenítése
<ul>
<li>interfész biztosítása, az utolsó látott tábla beállítására</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#világmodell-kialakítása" id="világmodell-kialakítása">Világ(modell) kialakítása</a></h2>
<p>A <em>világmodell</em> modul felelőssége a játék virtuális terének felépítése, az abban található elemek Objektum Orientált elveknek megfelelő hierarchiába szervezése, a virtuális tér elemeivel való interakciót biztosító (publikus) metódusok implementálása.</p>
<p>A modul bemenete a világ statikus elemeit tartalmazó állomány, amely XML és JSON formátumban is rendelkezésre áll. Ez a leíró fájl azonban csupán az objektumok síkbeli helyzetét, elforgatását és típusát tartalmazza. A modul felelőssége a többi modul igényeivel összhangban az objektumok további tulajdonságokkal történő felruházása. Például a rajzolást megkönnyíző <em>Z index</em> vagy az objektum térbeli kiterjedését szolgáló poligon definiálása.</p>
<p>A modullal kapcsolatos legfontosabb kihívás, hogy más csapatoktól érkező igényeket is teljesíteni kell, és „mindenki ezekre vár”. Így különösen fontos kezelni a sprinten belüli határidőket és prioritásokat. Például a deszerializált világobjektumok az első pillanattól kezdve szükségesek a megjelenítésért felelős csapat számára.
Valamint, hogy minden tervezési döntés érinti a többi csapatot is, még ha ők ennek nincsenek is mindig tudatában.</p>
<ul>
<li>Mielőbb el kell dönteni, hogy milyen koordináta-rendszerben dolgozik majd a modell.
Teljesen járható út, hogy a modell, az input állományban található koordináta-rendszer egy az egyeben alkalmazásra kerül, ebből adódóan minden számolás abban történik, csak a megjelenítés transzformálja át. (A teljes világ nem fog kiférni a képernyőre.)</li>
<li>El kell dönteni, hogy mi legyen az objektumok referenciapontja. A megjelenítés során forgatni kell az objektumokat, a <a href="virtual_world.html#az-%C3%BAt-elemek-viszony%C3%ADt%C3%A1si-pontjai">forgatási pont</a> nem egyezik meg a referenciaponntal, de a megjelenítésnek szükséges.</li>
<li>A világ objektumokhoz poligonokat kell társítani, ezek szolgálnak majd az ütközés valamint a látótérbe kerülés eldöntésére.</li>
<li>Fontos továbbá, hogy ezek a poliginok nem a képfájl szélei. A fa esetében csupán a törzsének lehet nekimenni, nem a lombkoronának, ezért a modellt ekképpen kell megalkotni! A törzsnek használható egy szabályos hasáb az egyszerűség kedvéért.
<ul>
<li><img src="images/tree_collidable.png" alt="" /></li>
</ul>
</li>
<li>Az autó is egyszerűsíthető, nem kell a grafikai elemet teljes mértékben követni.
<ul>
<li><img src="images/car_simplified_polygon_model.png" alt="" /></li>
</ul>
</li>
<li>A kanyarodó útelemeknél is lehet egyszerűsítést használni.
<ul>
<li><img src="images/90left_polygon.png" alt="" /></li>
</ul>
</li>
<li>A szűréshez használt háromszög esetében a poligonokat kell figyelembe venni, pl. fa törzse, tábla rúdja, de nem csak az „ütközhető” objektumokat kell tudni visszaadni, hanem az útelemeket is. A 2. sprintben a szenzorok majd válogatnak, hogy mire van szükségük ezekből.
<ul>
<li><img src="images/model_interface.png" alt="" /></li>
</ul>
</li>
<li>A poligonok megrajzolásához használható a <a href="https://www.robots.ox.ac.uk/%7Evgg/software/via/">VGG Image Annotator</a>, amely <a href="https://www.robots.ox.ac.uk/%7Evgg/software/via/via.html">böngészőből is működik</a> és a megrajzolt polygont JSON-ben le lehet menteni.
<ul>
<li>Korábbi félév során @ArchiCat és @konyarilaszlo ezt már megtette, elérhető a <a href="resources/worldobject_polygons.json">worldobject_polygons.json</a> állományban.</li>
</ul>
</li>
<li>A poligonok definiálásához célszerű a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/geom/package-summary.html">java.awt.geom</a> névteret használni. Ezek <code>intersects</code> könnyedén eldönthető, hogy egy objektum a szenzor látóterében van-e (amennyiben a szenzor is egy ilyen poligon).</li>
<li>A statikus objektumokon kívül a világ modell részét kell képzzék dinamikus, mozgó objektumok is.</li>
</ul>
<p>A tervezés során nem elegendő csupán az első sprint (meglehetősen szűk) követelményit figyelembe venni, hanem célszerű ezen túl a későbbi sprintek során valamennyi <em>user story</em>-ban felbukkanó követelmény kezelése. Természetesen nem elvárás a „jövőbe látás”, de törekedni kell minden logikusan előrelátható követelmény kezelésére.</p>
<h3><a class="header" href="#definition-of-done-1" id="definition-of-done-1">Definition of Done</a></h3>
<ul>
<li>Útelemeket, fákat, táblákat egyéb statikus objektumokat leíró állományok feldolgozása (deszerializálása)
<ul>
<li>kicsi pálya (test_world) és elemeinek megfelelő kezelése</li>
<li>nagy pálya (test_world_1kmx1km) és elemeinek megfelelő kezelése</li>
</ul>
</li>
<li>Hierarchikus objektummodell implementálása világ leírására, API biztosítása ennek elérésére,  lekérdezésére</li>
<li>Objektumok kiterjedését biztosító poligonok definiálása</li>
<li>Minden feldolgozott objektum rendelkezzen pozíció, referencia, orientáció, típusadatokkal</li>
<li>A modell legyen felkészítve az input fájlból kiolvasott „statikus” objektumokon túl mozgó („dinamikus”) objektumok kezelésére is
<ul>
<li>vezérelt autó, NPC (non-player-character) autó, gyalogos</li>
</ul>
</li>
<li>A modell tegyen különbséget azon objektumok között amelyeknek egy jármű nekimehet és amelyeknek nem (fa vs. útelem)</li>
<li>A modell kezeljen „z-index”-et, hogy a kirajzolás során biztosítható legyen, hogy mely elemet kell előtt kirajzolni a „kitakarások” végett</li>
</ul>
<h2><a class="header" href="#mozgatás-hajtáslánc-és-kormányzás" id="mozgatás-hajtáslánc-és-kormányzás">Mozgatás: hajtáslánc és kormányzás</a></h2>
<p>A <em>mozgatás</em> modul felelőssége a vezérelt autó (egocar) mozgatása, mozgásának számítása. Ez magába foglalja a hajtáslánc és a kormányzás megvalósítását.</p>
<p>A modul a HMI-től kap bemenetet, mindenek előtt váltóálás, gáz- és fékpedálállás valamint kormányelfordulás. A váltó automata, ami azzal jár, hogy a HMI a négy állapot (P, R, N, D) egyikét közli. </p>
<ul>
<li><strong>P</strong>ark: Ez az egyik olyan állapot amiben a motor beindítható (a másik az N), ez a váltó alapállása, mechanikusn megszűnteti az erőátvitelt. A valóságban nem helyettesíti kéziféket, de mivel azt nem kell implementálni a feladat során, lehet úgy tekinteni, hogy P-ben a kézifék is be van húzva. Az autó nem mozdul ebben az állásban.</li>
<li><strong>R</strong>everse: hátramenet</li>
<li><strong>N</strong>eutral: üres, ebben az állásban sem jut a motorerő tengelyekre, a motor nem gyorsíthatja az autót. Ha üresben gázt adunk, a motor felpörög, méghozzá jelentősen, mivel nincs ami ellene dolgozna. Ha az autónak volt lendülete, az még hajtja tovább.</li>
<li><strong>D</strong>rive: előremenet. A D-m belül definiálni kell 4-5 belső fogokatot (mint ahogy manuális váltónál is lenne), le kell progrramozni, hogy valamilyen fordulatszám értékeknél a váltó váltson. Ezen értékek mehatározásához lehet találni motorkarakterisztikákat (lehetőség szerint utcai autó kerüljön kiválasztásra, ne valami sportautó). A belső fokozatok a felhasználó interfész szempontjából transzparensek.</li>
</ul>
<p>A pedál állások [0-100] skálán érkeznek. 0: nincs lenyomva, 1: 1%-ig van lenyomva, 100: tövig (100%-ig) le van nyomva. Minél jobban le van nyomva a gázpedál, annál több teljesítményt kell a motornak kiadnia. A motor belső működését nem kell részletekbe menően implementálni, pláne nem egy belső égésű motorét, egy elektromos hajtáslánc egyszerűbb.
A szoftverben üzemenyagfogyasztást (vagy akkumulátor töltöttséget) és hatótávokat nem kell kezelni.</p>
<p>A kormány jellemzően valamilyen áttétel segítségévél befolyásolja a korányzott kerekek helyzetét. Ez ebben a szoftverben sokkal egyszerűbb is lehet. Ha 60°-ot tengelyelfordulást feltételezünk és a kormány „nulla” állásból +/- 60-at mozdulhat el, akkor lényegében 1:1-es Íáttételünk” van.
Ha az input +/- 100-as skálán adja meg a kormányelfordulás mértékét, akkor azt kell a tengelyelfordulásra képzeni. A bemeneti skálával kapcsolatban a HMI csapattal kell egyeztetni.</p>
<p>A úgymond kimenete egy mozgásvektor, vagyis az, hogy a következő ciklusban az autó (referenciapontjának) X, Y koordinátáit mennyivel kell módosítani.
A pedállálás és a motor korábbi állapotának függvényében meghatározásra kerül a sebesség, a kormányállás valamint az egocar korábbi orientációjának függvényében meghatározásra kerül, hogy módosul-e az autó iránya, a kettő eredőjeként a teljes vektor.</p>
<p>A modullal kapcsolatban kihívás a hajtáslánc működésének és a mozgás és kanyarodás fizikájának megértése, implelemtálása. A fizika tekintetében sem kell elaprózni a dolgokat. Két erő elégséges: a motorerő mint gyorsítja a járművet (ez a gázpedállal szabályozható) és egy fékező erő, amelyet a fékpedállal lehet szabályozni, valamint ezen felül egy konstans fékező erőnek is lennie kell, tehát a fékező erő akkor sem nulla, ha a fékpedál állsa nulla. Ez utóbbit mindegy minek nevezzük (légellenállás, csúszási-súrlódási erő, a kettő eredője, stb.), nem kell cicomázni, de legyen.</p>
<p>Külön feladat észben tartatni és célszerűen előre felkészülni arra, hogy a 3. sprintes vezetéstámogató modulok (LKA, AAC, AEB, PP) közvetlenül az egocar hajtásláncára és a kormányra hatnak. Fel kell készíteni a modult ilyen, „nem a HMI-ről” érkező inputok kezelésére is, amelyek ráadásul magasabb prioritásúak. Pl. ha a vészfékező rendszer „lenyomja” a fékpedált, akkor magasabb prioritással kell kezelni mint a HMI-ről érkező pedálállást.</p>
<h3><a class="header" href="#definition-of-done-2" id="definition-of-done-2">Definition of Done</a></h3>
<ul>
<li>Az autó gázpedál állásától függően gyorsul</li>
<li>A gyorsulás a „belső fokozatok” szerint kerül meghatározásra</li>
<li>Az autó a gázpedál felengedésével fokozatosan lassul, amjd megáll</li>
<li>Az autó R válóállásban tolat</li>
<li>Felkészíteni a modult, hogy a vészfékező, az adaptív tempomat vagy a parkoló asszisztens is küldhet inputot, melyek magasabb prioritásúak
<ul>
<li>vészfékező értelemszerűen fékezés inputot</li>
<li>az adaptív tempomat és a parkoló asszisztens gáz és fék inputot is</li>
</ul>
</li>
<li>Buszról érkező kormányállás felhasználása</li>
<li>Autó kanyarodásának biztosítása valóságos fordulókör szerint
<ul>
<li>ehhez szükséges extra tulajdonságot meghatározása</li>
</ul>
</li>
<li>Tényleges mozgásvektor meghatározása a motor csapat gyorsulás, lassulás értékének felhasználásával</li>
<li>A meghatározott mozgásvektor alapján az autó pozíciójának frissítése
<ul>
<li>az AutomatedCar osztály x,y koordinátáinak frissítése</li>
</ul>
</li>
<li>Tolatás során is valósághű kanyarodás történik</li>
<li>Felkészíteni a modult, hogy a sávtartó automatika vagy a parkoló asszisztens is küldhet kormányzás inputot</li>
</ul>
<h2><a class="header" href="#vizualizáció" id="vizualizáció">Vizualizáció</a></h2>
<p>A <em>vizualizációs</em> modul felelőssége a játék virtuális terének, pontosabban a képernyőn megjeleníthető részének kirajzolása miután a világ lényegesen nagyobb mint ami a programablakba egyszerre belefér. A modul csak megjelenít, a modellt a világmodellért felelős csapat állítja össze. Ebbe nem csak a pálya statikus elemei tartoznak, hanem értelemszerűen a dinamikus objektumok is. A megjelenítés középpontja az mindenkor vezérelt autó (egocar).</p>
<p>Továbbá, a modul felelőssége a debuggoláshoz és teszteléshez használandó segédobjektumok opionálisan bekapcsolható megjelenítése. Ide tartozik a szenzorok látómezeje, a világobjektumok „poligon váza”, valamint utóbbiak eseményre történő kiemelésének lehetősége.</p>
<p>A programablaknak az alábbi módon nézni majd ki. Két jól el különörő részre oszlik, a nagyobb baloldali a <em>viewport</em>, amemylen keresztük a világ éppen megjelenített része látható. A jobb oldali a műszerfal, amely <em>nem</em> tartozik e modul felelősségi körébe.</p>
<p><img src="images/gui_plan_course_display.png" alt="gui_plan" /></p>
<p>A modullal kapcsolatos kihívása a rajzoláshoz használt keretrendszer megismerése, az objektumtranszformációk megfelelő végrehajtása és az objektummodellért felelős csapattal egyeztetés az objektumok elérését illetően.
Bár a modul függ a világmodelltől, a munka értelemszerűen nem akkor kezdődik mikor az a modul elkészült. A világobjektumok képfájljai és a világot leíró állomány kezdettől fogva rendelkezésre áll, nem kell megvárni a teljes modell elkészültét.</p>
<h3><a class="header" href="#definition-of-done-3" id="definition-of-done-3">Definition of Done</a></h3>
<ul>
<li>a megjelenés villódzásmentes és folyamatos legyen</li>
<li>A kirajzolt világ egy része látható csak állandóan a programablakban, a „kamera” a vezérelt autót (egocar) követi
<ul>
<li>világ széleinek kezelése</li>
</ul>
</li>
<li>statikus objektumok pozícióhelyes kirajzolása és résmentes illesztése a rendelkezésre álló építőelemekből</li>
<li>mozgó objektumok helyes kirajzolása</li>
<li>debug célból meg kell tudni jeleníteni az egyes objektumokhoz definiált poligonokat</li>
<li>interfészt kell biztosítani, hogy egy megcímzett objektum poligonja eltérő színnel jelenhessen meg (ha kijelölésre kerül)</li>
<li>interfészt kell biztosítani a szenzorok látóterét jelképező háromszögek opcionális megjelenítésére
<ul>
<li>típusonként (radar, kamera, ultrahang) külön-külön kapcsolahatónak kell lennie és más-más színnel kell megjelnnie (piros, kék, zöld)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#1-ultrahang-szenzorok" id="1-ultrahang-szenzorok">1. Ultrahang Szenzorok</a></h1>
<p>Park pilot alapjául szolgáló Ultrasonic Sensor array szimulációjának implementálása.</p>
<ul>
<li>Input: világmodell</li>
<li>Output:
<ul>
<li>Ultrahang szenzor által látott objektumok</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#definition-of-done-4" id="definition-of-done-4">Definition of Done</a></h3>
<ul>
<li>8 db ultrahang szenzor, egyenként 3 méter látótávolsággal, 100° látószöggel</li>
<li>A 8 darab háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li>debug célra bekapcsolható módon ezek a háromszögek legyen kirajzolhatóak <strong>zöld</strong> színnel</li>
<li>A látószög és távolság által meghatározott területen kérjék el a <strong>releváns</strong> objektumokat</li>
<li>Határozzák meg a legközelebbi (ütközés szempontjából) objektum pozícióját, kiterjedését, távolságát</li>
<li>A legközelebbi objektum legyen vizuálisan kiemelve</li>
</ul>
<h3><a class="header" href="#megjegyzések" id="megjegyzések">Megjegyzések</a></h3>
<ul>
<li>A háromszög kirajzolására már kell, hogy legyen elérhető publikus metódus, amely 3 pontot és egy rajzolási színt vár bemenetként</li>
<li>A világ objektumainak lekérdezésére már kell, hogy legyen elérhető publikus metódus, mely 3 pontot vár bemenetként, ebből kell leválogatni a relevánsakat</li>
<li><img src="images/ultrasonic.png" alt="" /></li>
</ul>
<h1><a class="header" href="#2-kamera-szenzor-implementálása-Ütközés-detekció-és-mozgásállapot-változás-szimuláció" id="2-kamera-szenzor-implementálása-Ütközés-detekció-és-mozgásállapot-változás-szimuláció">2. Kamera szenzor implementálása, Ütközés detekció és mozgásállapot-változás szimuláció</a></h1>
<p>Sávtartó automatika és táblafelismerő alapjául szolgáló kamera szenzor implementációja. A Sávtartó automatika a nagyobb feladat, ugyanis meg kell tudni határozni a sávot. Az autó előtt levő pályaelemekből kiszámítani, hogy hol vannak a sávot meghatározó vonalak. A sávtartó automatikának arra lesz majd szüksége, hogy az autó közelít-e a sávját meghatározó felfestésekhez.</p>
<ul>
<li>Input: világmodell</li>
<li>Output:
<ul>
<li>Kamera által látott objektumok</li>
<li>esemény kiváltása ütközések bekövetkezésekor
<ul>
<li>ez írja le, hogy mik ütköztek</li>
<li>??? új mozgásállapot minden mozgó, ütköző objektumnak</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#definition-of-done-5" id="definition-of-done-5">Definition of Done</a></h2>
<ul>
<li>1 db, a szélvédő mögé elhelyezett kamera implementálása</li>
<li>A látószög és távolság által meghatározott területen kérje el a <strong>releváns</strong> objektumokat
<ul>
<li>a táblafelismerő szempontjából releváns objektumok a táblák</li>
<li>a sávtartó szempontjából releváns objektumok az utak</li>
</ul>
</li>
<li>A háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li>debug célra bekapcsolható módon a háromszög legyen kirajzolható <strong>kék</strong> színnel</li>
<li>A szenzorok által relevánsnak tartott objektumok vizuálisan kiemelhetők egy debug kapcsolóval (billentyű vagy debug módba váltás)</li>
</ul>
<!-- - A kamera szenzor a látható sávok összes adatát visszaadja(hány sáv, melyikben vagyunk, azon belül milyen távolságra a szélektől)
- A kamera szenzor a látott táblák közül a legközelebbi összes adatát visszaadja (milyen tábla, milyen messzire van) -->
<hr />
<ul>
<li>A vezérelt autó - tereptárgy ütközésének detektálása és esemény kiváltása</li>
<li>A vezérelt autó - NPC-vel való ütközésének detektálása és esemény kiváltása</li>
<li>Mozgó és statikus objektumok érintkezésének pozíció és dimenzióhelyes detekciója és kommunikációja megvalósult</li>
<li>Az objektumok mozgásállapota az energiamegmaradás törvényeinek megfelelően változik (gyorsul, lassul, irányt vált, megáll)
<ul>
<li>Ha a vezérelt autó nekimegy egy NPC autónak akkor ez legyen rá hatással (lassuljon le)</li>
<li>Ha a vezérelt autó nekimegy egy „stabil” tereptárgynak (pl. fa), akkor álljon meg, érjen véget a játék, egy táblán azonban át tud menni (el tudja sodorni), lassuljon le</li>
</ul>
</li>
<li>Az objektumok sérülnek, megsemmisülnek, amennyiben túl nagy energiával ütköznek</li>
<li>Ha a vezérelt autó elüt egy gyalogost, akkor érjen véget a játék</li>
<li>A játék véget ér, ha a játékos ütközés következtében mozgásképtelenné válik (megsemmisül)</li>
</ul>
<h2><a class="header" href="#megjegyzés" id="megjegyzés">Megjegyzés</a></h2>
<ul>
<li>A háromszög kirajzolására már kell, hogy legyen elérhető publikus metódus, amely 3 pontot és egy rajzolási színt vár bemenetként</li>
<li>A világ objektumainak lekérdezésére már kell, hogy legyen elérhető publikus metódus, mely 3 pontot vár bemenetként, ebből kell leválogatni a relevánsakat</li>
<li>A kamerának előre kell látnia, ha az út kanyarodni fog, azt is, hogy merre fog kanyarodni és erről a sávtartó automatikának használható információt kellene előállítani</li>
<li>A valóságban kiszámolják a pálya görbét, ezt itt oly módon oldható meg, hogy a sávhatárokat és ezekhez tud majd a sávtartó automatika viszonyítani</li>
<li>Továbbá figyelni kell, hogy az autó sebességének függvényében hol lesz a következő időpillanatban (pl. másodperc múlva). Le fog-e térni az útról ha beavatkozás nem történik, mert akkor a sávtartó automatikának közbe kell avatkoznia. Ez itt még nem feladat, de a következő sprintben az lesz, így célszerű észben tartani</li>
<li><img src="images/camera.png" alt="" /></li>
</ul>
<hr />
<ul>
<li>Az ütközés detektálása implementáció szempontjából nagyon hasonló a világ objektumainak lekérdezéséhez. Az kell bizsgálni az <code>intersects</code> metódussal, hogy két objektum összeér-e.</li>
<li>Az NPC - NPC ütközés nem fontos, tehát NPC autó ha átmegy a gyalogoson nem kell, hogy kiváltson különösebb reakciót</li>
<li>jellemző megoldásként az <em>egocar</em> szokott kapni egy sérülés/élet értéket a mozgásképtelenséghez</li>
</ul>
<h1><a class="header" href="#3-világ-populálása-mozgó-npc-objektumokkal" id="3-világ-populálása-mozgó-npc-objektumokkal">3. Világ populálása mozgó NPC objektumokkal</a></h1>
<ul>
<li>Input: Világmodell</li>
<li>Output: Mozgó NPC objektumok, gyalogosok, biciklisek, autók. szkriptelt útvonalak, mozgások megvalósítása, a megvalósított objektumok a modellbe illesztése</li>
<li>Challenge: adaptálódás pályához</li>
</ul>
<h3><a class="header" href="#definition-of-done-6" id="definition-of-done-6">Definition of Done:</a></h3>
<ul>
<li>Objektumok előre definiált, értelmes helyen jelennek meg (autók úton, gyalogosok út mellett/járdán)</li>
<li>Objektumok előre szkriptelt útvonalat követnek</li>
<li>Gyalogosok az út mentén haladnak, zebrán áthaladnak</li>
<li>Autók az utat - sávot - pontosan követik</li>
<li>NPC objektumok egymás mozgásállapotát nem változtatják meg</li>
<li>Legalább egy autó végigmegy a pályán</li>
<li>Legalább egy gyalogos mozog és átkel egy zebrán</li>
<li>Új pálya esetén az NPC objektumok adaptálódnak az új környezethez</li>
</ul>
<h3><a class="header" href="#megjegyzések-1" id="megjegyzések-1">Megjegyzések</a></h3>
<ul>
<li>NPC = <em>non player character</em> (itt akár <em>car</em> is lehet)</li>
<li>Feltételezhető az NPC-k szabálykövető és értelemszerű viselkedése: nem hajt gyorsan, nem tér le az útról, nem ütközik fának.</li>
<li>A gyalogoson akár átmehet, nem kell ütközésnek minősíteni.
<ul>
<li>Az érdekes ugyanis az, hogy az egocar (vezérelt autó) hogyan viselkedik egy mozgó objektumra, másik autó (nem megy neki), gyalogos (nem üti el), az NPC-ket nem kell túlbonyolítani</li>
</ul>
</li>
<li>Szkriptelt útvonal alatt azt értjük, hogy a világ koordinátáira építve bele van égetve a kódba (esetleg egy konfigurációs fájlba), hogy az autó hogyan mozogjon. Például a parkoló mellől indul az úton megy fölfele (csökken az y koordinátája) a kanyar előtt (x,y) világkoordinátákat elérve lelassul, (x,y)' koordináták elérése esetén elkezd kanyarodni, a sávból nem tér ki, majd (x,y)&quot; koordinátáig halad a fönti egyenesen. És így tovább.</li>
<li>a kanyarodás legyen a lehető legvalósághűbb, akár a vezérelt autó esetében.</li>
</ul>
<h1><a class="header" href="#4-radar-szenzor" id="4-radar-szenzor">4. Radar szenzor</a></h1>
<p>Adaptív sebességtartó, automata vészfékező alapjául szolgáló radar szenzor implementációja</p>
<ul>
<li>Input: világmodell</li>
<li>Output:
<ul>
<li>Radar által látott objektumok</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#definition-of-done-7" id="definition-of-done-7">Definition of Done</a></h2>
<ul>
<li>1 db, az autó első lökhárítója mögött elhelyezett radar szenzor</li>
<li>A látószög (60°) és távolság (200m) által meghatározott területen kérjék el a <strong>releváns</strong> objektumokat</li>
<li>A háromszög koordinátái az autó helyzetétől függően folyamatosan frissülnek</li>
<li>debug célra bekapcsolható módon a háromszög legyen kirajzolhatóak <strong>piros</strong> színnel</li>
<li>Határozzák meg a legközelebbi, sávon belüli (lateral offset alapján) objektum helyzetét</li>
<li>Az automata vészfékező számára releváns objektumok (az autó középvonala felé halad, látjuk) kiválogatása és visszaadása</li>
<li>A legközelebbi objektum legyen vizuálisan kiemelve</li>
</ul>
<h2><a class="header" href="#megjegyzések-2" id="megjegyzések-2">Megjegyzések</a></h2>
<ul>
<li>A háromszög kirajzolására már kell, hogy legyen elérhető publikus metódus, amely 3 pontot és egy rajzolási színt vár bemenetként</li>
<li>A világ objektumainak lekérdezésére már kell, hogy legyen elérhető publikus metódus, mely 3 pontot vár bemenetként, ebből kell leválogatni a relevánsakat</li>
<li><img src="images/radar.png" alt="" /></li>
<li>A vészfékezőnek majd ki kell tudnia számolni, hogy az akadály akkor is útban lesz-e még mire az autó odaér, ehhez szükséges az útban levő objektum távolsága és pozíciója (relatívan az autóhoz), ez minden ciklusban lefutva előállítja az objektum pl. gyalogos mozgásvektorát
<ul>
<li>ennek egy fa esetében is működnie kell, csak az nem mozog, mert nem Középföldén vagyunk</li>
</ul>
</li>
<li>az ACC-hez el kell tudni dönteni, hogy pl. egy autó a vezérelt autó előtt halad-e</li>
</ul>
<h1><a class="header" href="#1-automata-parkolás" id="1-automata-parkolás">1. Automata parkolás</a></h1>
<ul>
<li>Input: Ultrahang szenzorok</li>
<li>Output: parkolási manőver végrehajtása</li>
</ul>
<h3><a class="header" href="#dod" id="dod">DoD</a></h3>
<ul>
<li>Indexkapcsoló állása alapján parkolóhely keresés jobbra vagy balra</li>
<li>Autó méretének megfelelő hely beazonosítása</li>
<li>Megtalált parkoló jelzése, a hely információinak buszra írása (packet-tel)</li>
<li>A parkolóhely megtalálásához szükséges NPC-k példányosítása</li>
<li>A parkolás megkezdése külön inputhoz kötött (van erre vonatkozó gomb a műszerfalon, inputtól meg billentyűesemény)</li>
<li>A kormány és gáz/fék vezérlésével beparkolás a talált helyre</li>
<li>Párhuzamos parkolás sikeres (ütközés nélkül megtörténik)</li>
<li>Sofőr beavatkozására (fék, gáz, kormány) kikapcsolás (megszűnik az automata vezérlés)</li>
</ul>
<h3><a class="header" href="#megjegyzések-3" id="megjegyzések-3">Megjegyzések</a></h3>
<ul>
<li>Még a sofőr vezet a parkolóig, megáll az autósor mellett aktiváltja a parkolóhely keresést (kell valami input a billentyűzetről) ekkor továbbra is &quot;emberi&quot; irányítással el kell haladni a parkolóhelyek mellett és ki kell számolni a szabad hely méretét. Amikor megvan az alkalmas hely, akkor visszajelzést kell adni és a hely dimenziót és az autóhoz viszonyított helyzetét le kell tudni írni.</li>
<li>Az autónak elérhető a referenciapontja (továbbá ismert a szélessége és a hosszúsága), a autóhoz (referenciaponthoz) viszonyítva legyen leírva a parkolóhely.</li>
<li>Ami a parkolóhely hosszát illeti, nem a felfestett parkolóhely hosszát kell lemérni (azt nem is lehet az ultrahang szenzorral), hanem a szabad parkolóhelyet közrefogó két parkoló autó által szabadon hagyott helyet (amely akár két felfestésnyi is lehet).</li>
<li>A szabad hely szélessége ha egyéb akadályt - pózna (<code>bollard.png</code>) vagy fa - nem tesztek külön emiatt, támpontként a pályára, akkor a a szenzor látótávolsága, azaz 3 méter.</li>
<li>a szabad helyhez egy referenciapontot kell (érdemes) társítani, pl. a helyet leíró téglalap bal felső pontja (ábrán így van) és az autó középpontjával és ezzel a ponttal (ebből számolható a távolság) valamint a hely dimenzióival kielégítően jellemezve van a parkoló hely.</li>
<li>Ez tartalmazza az autó referenciapontját (középpont) és a pakolóhelyet leíró négyzet referenciapontját ezekből számítható a távolságuk.</li>
<li>(Ha más nem próbálgatásos módszerrel) ki kell tapasztalni, hogy a szükséges &quot;párhuzamos parkolás&quot; manőver hogyan vihető végbe a vezérelt autó irányítószerveivel, majd ezt le kell automatizálni: pl. le kell írni, kormány jobbra teker 100-ra, gáz 25% 1,5s-ig, majd kormány balra 75, gáz 20% 1.25s-ig.</li>
<li>A programozott vezérlést a buszon keresztül kapott szabad helyet leíró adatok függvényében kell elindítani</li>
<li>ha szükséges az autóval tolatni is kell a manőver megkezdéséhez, mivel a detektálás során túlmehetünk az ideális pozíción, ahonnan a leprogramozott manőver ütközés nélkül beparkol.</li>
</ul>
<p><img src="images/parking_horizontal.png" alt="" />
<img src="images/find_parking_place_horizontal.png" alt="" />
<img src="images/parking_place_found_horizontal.png" alt="" /></p>
<h1><a class="header" href="#2-sávtartó-automatika-és-táblafelismerés" id="2-sávtartó-automatika-és-táblafelismerés">2. Sávtartó automatika és táblafelismerés</a></h1>
<ul>
<li>Input: Kamera szenzor</li>
<li>Output:
<ul>
<li>Sávot beavatkozás nélkül követi a vezérelt autó</li>
<li>Az utolsó látott tábla megjelenik a HMI-n</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#definition-of-done-8" id="definition-of-done-8">Definition of Done</a></h2>
<ul>
<li>45 foknál enyhébb kanyarodású úton a kocsi a sáv szemmel láthatóan a sáv közepén marad</li>
<li>Ha el kell engednie a kontrollt (az automatika számára kezelhetetlen forgalmi szituáció következik, pl. éles kanyar, kereszteződés), vizuális figyelmeztetést ad</li>
<li>Ha újra elérhető a funkció (pl. elhagytuk a kanyart) vizuális indikáció (a műszerfalon)</li>
<li>Sávtartó automatika be- és kikapcsolható
<ul>
<li>emberi beavatkozásra kikapcsol</li>
</ul>
</li>
<li>az utolsó látott, releváns tábla megjelenik a műszerfalon</li>
<li>az utolsó sebességkorlátozás kiírásra kerül a buszra</li>
</ul>
<h2><a class="header" href="#megjegyzések-4" id="megjegyzések-4">Megjegyzések</a></h2>
<ul>
<li>a tábla megjelenítésére kész interfész van a műszerfaltól, csak meg kell hívni, ha a detektálás megtörtént</li>
</ul>
<p><img src="images/lka.png" alt="" /></p>
<p>Sávon belüli mozgás: a LKA működése egy enyhe sávon belüli cikázást eredményez.</p>
<p><img src="images/lka_wave.png" alt="" /></p>
<h1><a class="header" href="#3-adaptív-tempomat" id="3-adaptív-tempomat">3. Adaptív tempomat</a></h1>
<ul>
<li>Input:
<ul>
<li>radar szenzor</li>
<li>NPC autók</li>
</ul>
</li>
</ul>
<p>Adaptív tempomat funkció megvalósítása - a kiválasztott célobjektum (autó előtt haladó NPC) sebességéhez igazítja a gyorsabb saját sebességet, vagy tartja a sofőr által kiválasztott sebességhatárt, ha nincs cél.</p>
<h2><a class="header" href="#definition-of-done-9" id="definition-of-done-9">Definition of Done</a></h2>
<ul>
<li>Bekapcsolható, reagál az állapotváltás, alapértelmezetten az aktuális sebesség, de min célsebesség 30 km/h</li>
<li>ha nincs saját sávban autó, a játékos autó tartja a kiválasztott célsebességet</li>
<li>ha saját sávban található autó:
<ul>
<li>a saját jármű felveszi a sebességét, ha lassabb</li>
<li>tartja a kiválasztott sebességet, ha gyorsabb</li>
</ul>
</li>
<li>fékezésre kikapcsol</li>
<li>AEB beavatkozásra kikapcsol</li>
<li>Ha speed limitet talál a buszon, azt alkalmazza új célsebességként, amíg a sofőr felül nem írja</li>
</ul>
<h2><a class="header" href="#megjegyzések-5" id="megjegyzések-5">Megjegyzések</a></h2>
<ul>
<li>Szabad feltételezni, hogy az NPC kezelés nem, vagy nem időben készül el, lesz elérhető (kerül be a masterba)</li>
<li>Ezért célszerű a felhasználó/vezető által megadott sebességhez igazodással kezdeni, ennek akkor is működnie kell, ha nincs NPC a pályán</li>
<li>A modul olyan triggerekkel vezérelheti az autót mint amilyenek a billentyűlenyomás kezelőtől jönnek (gáz, fék)
<ul>
<li>de figyelni kell, hogy a tényleges billentyűtől érkező inputok felülírják a funkciót</li>
</ul>
</li>
</ul>
<p><img src="images/acc.png" alt="" /></p>
<ul>
<li>Oda kell figyelni, hogy csak a sávban előttünk haladó autót vegye figyelembe, a szembejövőt ne</li>
</ul>
<h1><a class="header" href="#4-vészfékező" id="4-vészfékező">4. Vészfékező</a></h1>
<p>Automata vészfékező rendszer megvalósítása, maximum 9 m/s^2 lassulással</p>
<ul>
<li>Input: radar szenzor</li>
</ul>
<h2><a class="header" href="#definition-of-done-10" id="definition-of-done-10">Definition of Done</a></h2>
<ul>
<li>Elkerülhető ütközés esetén vizuális figyelmeztetés a sofőrnek</li>
<li>ha a sofőr nem avatkozik közbe, automatikus fékezés (az utolsó pillanatban, ahol az ütközés még elkerülhető)</li>
<li>az automatikus fékezés mértéke a sebességgel arányos, de nem lehet 9 m/s^2-nél nagyobb</li>
<li>70 km/h felett figyelmeztetés, hogy az AEB nem tud minden helyzetet kezelni</li>
<li>Nincs nem releváns objektumokra való fékezés (fals pozitív) - pl. szembejövő autó</li>
<li>Gyalogosra, fára megáll a kocsi</li>
</ul>
<h2><a class="header" href="#megjegyzések-6" id="megjegyzések-6">Megjegyzések</a></h2>
<ul>
<li>A radar vissza kell adja az autó előtt levő legközelebbi releváns objektum adatait (táv, sebesség), ezekkel lehet számolni</li>
<li>A távolságból és az autó sebességéből meghatározható, hogy milyen lassulást kell adni az autónak, hogy még megálljon, de ne lépje túl a 9 m/s^2-et
<ul>
<li>a gyorsítási/fékezési input nem gyorsulásban van, hanem pedállás mértékben. Ebből elvileg egyszerűen nem nyerhető ki a gyorsulás, viszont a gyorsulás az egy másodperc alatti sebesség változás, ami viszont kiszámolható t(n) - t(n-1) módon</li>
</ul>
</li>
<li>A modul olyan triggerekkel vezérelheti az autót mint amilyenek a billentyűlenyomás kezelőtől jönnek (gáz, fék)
<ul>
<li>de figyelni kell, hogy a tényleges billentyűtől érkező inputok felülírják a funkciót</li>
</ul>
</li>
</ul>
<p><img src="images/radar_aeb.png" alt="" /></p>
<h1><a class="header" href="#munkakörnyezet" id="munkakörnyezet">Munkakörnyezet</a></h1>
<h1><a class="header" href="#git" id="git">Git</a></h1>
<!-- toc -->
<h2><a class="header" href="#interaktív-online-oktató-anyagok" id="interaktív-online-oktató-anyagok">Interaktív online oktató anyagok</a></h2>
<ol>
<li><a href="https://www.katacoda.com/courses/git">Webes interaktív oktatóanyag</a>
<ul>
<li>GitHub fiókkal -többek közt- a git kurzus ingyenesen végigvihető</li>
<li>az első 6 modul mindenképpen ajánlott</li>
</ul>
</li>
<li><a href="http://learngitbranching.js.org/">Learn Git Branching</a>
<ul>
<li>ez kifejezetten a branchelésre megy rá, szóval nem véletlenül a második!</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#online-anyagok" id="online-anyagok">Online anyagok</a></h2>
<ul>
<li><a href="http://smutch.github.io/VersionControlTutorial/">Version Control Tutorial</a>
<ul>
<li>kezdőknek, az alapoktól</li>
</ul>
</li>
<li><a href="http://rogerdudler.github.io/git-guide/">git - the simple guide</a>
<ul>
<li>inkább újrakezdőknek, ismétlés szintű</li>
</ul>
</li>
<li><a href="https://www.atlassian.com/git/tutorials">Altassian Git tutoriálja</a></li>
<li><a href="http://goalkicker.com/GitBook/">Git Notes for Professionals book</a>
<ul>
<li>haladókank, nem tanítja a git használatát, de <em>probléma: megoldás</em> alapon összefoglalja a használatának majd minden aspektusát (a Stackoverflow válaszok alapján)</li>
</ul>
</li>
<li><a href="https://git-scm.com/book/en/v2/">Git könyv</a>
<ul>
<li>mindent tartalmaz a gitről, gyakorlatilag a fejlesztők által írt dokumentáció</li>
<li><a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">&quot;git branching in a nutshell&quot;</a> fejezete viszont minimum ajánlott</li>
</ul>
</li>
<li><a href="https://help.github.com/articles/syncing-a-fork/">Fork szinkronizálása</a></li>
</ul>
<h3><a class="header" href="#puskák-pdf-formátumban" id="puskák-pdf-formátumban">Puskák PDF formátumban</a></h3>
<ul>
<li><a href="https://education.github.com/git-cheat-sheet-education.pdf">GitHubtól</a></li>
<li><a href="https://about.gitlab.com/images/press/git-cheat-sheet.pdf">GitLabtól</a></li>
<li><a href="https://www.atlassian.com/dms/wac/images/landing/git/atlassian_git_cheatsheet.pdf">Altassiantól (BitBucket)</a></li>
</ul>
<h2><a class="header" href="#kliensek" id="kliensek">Kliensek</a></h2>
<p>A fejlesztői környezetek rendelkeznek Git integrációval, de a parancssoron kívül grafikus kliensek is <a href="https://git-scm.com/downloads/guis">léteznek</a>, többek között a <a href="https://desktop.github.com/">GitHub saját asztali kliense</a>.</p>
<ul>
<li><a href="https://gitforwindows.org/">Git for Windows</a></li>
</ul>
<h2><a class="header" href="#egyéb" id="egyéb">Egyéb</a></h2>
<ul>
<li>Egy commit üzenet utólagos megváltoztatása <a href="https://help.github.com/articles/changing-a-commit-message/">nem egyszerű</a> (különösen ha pusholva lett, lokálisan még nem is olyan vészes), így eleve írjuk meg korrekten.</li>
<li>Ha többen dolgoztok egy módosításon akkor a commit üzenet láblécében tüntessétek föl a <a href="https://help.github.com/articles/creating-a-commit-with-multiple-authors/">társszerzőket is</a>.</li>
</ul>
<h1><a class="header" href="#github" id="github">GitHub</a></h1>
<p>A félév során a GitHubot használjuk a kód tárolására, a feladatok menedzselésére is és kommunikációra is.</p>
<h2><a class="header" href="#oktatóanyagok" id="oktatóanyagok">Oktatóanyagok</a></h2>
<ul>
<li><a href="https://lab.github.com/"><strong>interaktív oktatófelület</strong></a></li>
<li><a href="https://guides.github.com/">GitHub Guides</a></li>
</ul>
<h2><a class="header" href="#Áttekintés" id="Áttekintés">Áttekintés</a></h2>
<p>Minden hallgató tagja lesz a <a href="https://github.com/SzFMV2020-Osz/">SzFMV2020-Osz</a> szervezetnek (<code>Organization</code>), és egy-egy csapatnak (Team A[1-4], Team B[1-4]). Minden csapat külön issue board-dal rendelkezik (<code>Projects</code>), ezen kell vezetni a feladatok (<code>issue</code>) megoldását (részletében lásd <a href="workflow.html">Munkafolyamat</a>).</p>
<p>Issue-t nem csak feladatra lehet felvenni, akár kérdésre is (felénk vagy más csapatok felé is), probléma megvitatására is. Ez esetben célszerű megjelölni a <code>type: question</code> címkével. 2017 őszétől csapat (<code>team</code>) szintű fórummal (<code>Discussions</code>) is rendelkezik a GitHub. A szervezeten belül a csapatok hierarchikus struktúrában vannak. A gyökér az <a href="https://github.com/orgs/szfmv2020-osz/teams/everyone">Everyone</a>, az összes többi csapat ennek tagja (Group A, Group B csapatokon keresztül). Az Everyone falára írt üzeneteket mindenki megkapja. Ezen keresztül fogunk a félév során kurzus szintű közleményeket kiadni, de bárki használhatja kommunikációra. Ugyanilyen üzenőfallal rendelkezik az összes többi csapat is, amelyre szintén bárki írhat. Ha például a Team2-ből szeretné elérni valaki a Team3-at, akkor mindösszesen annyi a dolga, hogy ír a Team3 üzenőfalára. A <a href="https://github.com/orgs/SzFMV2020-Osz/teams/instructors">Instructors</a> nevű team-en keresztül az oktatókat lehet elérni ugyanilyen módon.</p>
<p>A comment szekciókban is élnek az @ jeles említések, ez a mi esetünkben <code>@ravaszla</code> és <code>@pintergreg</code>, ugyanígy működik csapatra is pl. <code>@szfmv2020-osz/team-a1</code>, illetve <code>@szfmv2020-osz/instructors </code> a mi esetünkben. Csapat esetében a csapat valamennyi tagja kap értesítést az hivatkozásról.</p>
<p>A GitHub valamennyi elemén használhatóak formázási lehetőségek <a href="https://guides.github.com/features/mastering-markdown/">Markdown stílusban</a>, kód kiemelésre is lehetőség van, amelyet több mint célszerű használni. Ehhez csak a nyelv nevét kell csak a nyitó  ``` jelek után írni:</p>
<pre>
```python
def get_random_number():
    return 4;  # chosen by fair dice roll. guaranteed to be random.
```
</pre>
<p>Eredmény:</p>
<pre><code class="language-python">def get_random_number():
    return 4;  # chosen by fair dice roll. guaranteed to be random.
</code></pre>
<h2><a class="header" href="#címkék" id="címkék">Címkék</a></h2>
<p>Létrehozásra kerültek címkék (<code>Labels</code>) négy „dimenzióban” (vagy kategóriában), amelyek használata elvárás a létrehozott issue-khoz a munka áttekinthetőségének javítása miatt. Kell, hogy legyen az issue-nak típusa, állapota, prioritása és legyen megjelölve a feladat nehézsége is.</p>
<p><img src="images/labels.png" alt="" /></p>
<h3><a class="header" href="#típus-type" id="típus-type">Típus (type)</a></h3>
<ul>
<li>bug</li>
<li>design</li>
<li>documentation</li>
<li>enhancement</li>
<li>integration</li>
<li>question</li>
<li>user story</li>
</ul>
<h3><a class="header" href="#Állapot-status" id="Állapot-status">Állapot (status)</a></h3>
<ul>
<li>completed</li>
<li>duplicate</li>
<li>help wanted</li>
<li>invalid</li>
<li>pending</li>
<li>review needed</li>
</ul>
<h3><a class="header" href="#prioritás-priority" id="prioritás-priority">Prioritás (priority)</a></h3>
<ul>
<li>critical</li>
<li>high</li>
<li>moderate</li>
<li>low</li>
</ul>
<h3><a class="header" href="#nehézség-effort" id="nehézség-effort">Nehézség (effort)</a></h3>
<ul>
<li>high</li>
<li>moderate</li>
<li>low</li>
</ul>
<!--
## Pull requestek kezelése:  review és ütközésfeloldás

Előfordulhat, hogy a git nem tudja feloldani a változtatásokat és emberi beavatkozást igényel a merge-elés. Például létrehoztad a feature branchet a csapat branch adott állapotáról, ám az időközben módosult és a módosítás ugyanazon fájl ugyanazon részét érintette. A GitHubon ez az alábbihoz hasonlóan néz ki:

![PR conflict](https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/conflict.png)

Ezen belül is egyszerűbb esetekben a GH felajánlja a webes szerkesztőjét, de összetettebb esetekben ki kell checkolni az adott ágat és „kézzel” (editorral) feloldani helyzetet.

**Fontos!** A masterbe nem fogadunk el olyan PR-et, amelyben ütközés van, mivel jellemzően nem tudjuk eldönteni, hogy melyik változat fele meg „az utoljára megbeszélteknek”.

### Webes szerkesztő

A képen az  látható, hogy Hegedűs kolléga a `master` azon állapotában írta be a nevét, amikor a 64. sor volt az utolsó. Időközben egyéb PR-eket is elfogadtam így a git nem tudja, hogy a 68-73. sorokat kell megtartani vagy a 66.-at (ennek szintaktikáját látni a „kacsacsőrökkel”).

![GH web editor](https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/conflict_web_editor.png)

 Jelen esetben persze mindkettő kell, így kézzel átrendezem, majd ezt megjelölöm feloldottnak:

![GH web editor](https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/conflict_web_editor2.png)
![conflict resolved](https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/conflict_mark_resolved.png)

**További tippek a témában**: https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git

Ekkor a GH azt mutatja, hogy nincs ütközés, de review szükséges (ha nem is volt ütközés, akkor innen indul a történet).

### Lokális szerkesztő

Ha a GH webes felületén nem engedi az ütközés feloldását, akkor lokálisan kell. Az IDEA pl. az alábbi három paneles megoldást kínálja. Csak rá kell kattintgatni arra, amelyiket meg akarjuk tartani (vagy kézzel összemásolni mint a fönti példa esetében).

Ha valaki parancssorból intézi, akkor a beállított editorral nyitja meg (vi, nano, stb.) és szintaktikailag ugyanazt a megoldást kapja mint a webes editor esetében.

![](http://www.tilcode.com/wp-content/uploads/2015/09/intellij_merge_conflict_tool.png)
-->
<h2><a class="header" href="#branching-modell" id="branching-modell">Branching modell</a></h2>
<p>Csoportos munka során fontos tisztázandó kérdés, hogy milyen stratégiával kezeljük a branch-eket. Az egyik legismertebb talán a GitFlow (<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>), amelyet mára több kritika is ért.</p>
<p>A legelterjedtebbek tőbb tulajdonságait Scott Shipp <a href="https://dev.to/scottshipp/war-of-the-git-flows-3ec2">War of the Git Flows</a> című cikke nyomán a következő táblázatban foglaltam össze:</p>
<table><thead><tr><th></th><th>GitFlow</th><th>GitHub Flow</th><th>OneFlow</th><th>GitLab Flow</th><th>Trunk-Based Development</th><th>Rebasing Flow</th></tr></thead><tbody>
<tr><td>Uses feature branches</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>optionally, if short lived</td><td>no</td></tr>
<tr><td>Uses release branches</td><td>yes</td><td>no</td><td>yes</td><td>yes</td><td>yes</td><td>optional</td></tr>
<tr><td>Uses rebasing</td><td>no</td><td>no</td><td>optional</td><td>optional</td><td>optional</td><td>yes</td></tr>
<tr><td>Merges</td><td>no fast forward merges</td><td>unclear</td><td>up to you</td><td>up to you</td><td>optional</td><td>no</td></tr>
</tbody></table>
<ul>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></li>
<li><a href="https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/">A succesful Git branching model considered harmful</a></li>
<li><a href="https://trunkbaseddevelopment.com/">Trunk-Based Development</a></li>
<li><a href="https://guides.github.com/introduction/flow/">GitHubFlow</a></li>
<li><a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">GitLabFlow</a></li>
<li><a href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#oneflow-advantages">OneFlow</a></li>
<li><a href="https://gist.github.com/jbenet/ee6c9ac48068889b0912">a simple git branching model</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">Comparing Workflows</a></li>
</ul>
<p>A korábbi félévekben a GitFlow szerű megoldást használtuk megbonyolítva azzal, hogy minden csapatnak saját fejlesztői branche-e volt. Ezt jelentősen leegyszerűsítendő a <a href="https://guides.github.com/introduction/flow/">GitHubFlow</a>-ra váltunk.</p>
<p>A <code>master</code> branch <a href="https://docs.github.com/en/github/administering-a-repository/about-protected-branches">védett</a>, nem lehet bele commitolni. Minden feladatohoz tartoznia kell egy issue-nak, és a megoldásához létre kell hozni egy (feature) branchet az aktuális masterről. A feladatot azon kell megoldani, majd PR-et nyitni a masterbe.</p>
<p>Ahhoz, hogy a masterbe kerülhessen a módosítás több követelménynek is teljesülnie kell:</p>
<ul>
<li>a kód fordul</li>
<li>az összes teszt sikeres</li>
<li>két csapattárs és egy oktató jóvá hagyta (review)</li>
<li>nincs ütközés (conflict)</li>
</ul>
<!-- ![](https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/branching.png) -->
<!-- A `master` branch védett, nem lehet bele commitolni. Nem egy, hanem több (4) fejlesztői branch-ünk van (`team1`, ..., `team4`), ezek szintén védettek. Minden feladathoz létre kell hozni egy *feature branch-et*, azon lehet dolgozni. Ha a feladat elkészült, akkor a csapat branchbe lehet *merge-eni*. Ami mivel védett [*pull request-et*](https://help.github.com/articles/about-pull-requests/) (továbbiakban PR) küldeni. A PR lehetőséget biztosít ellenőrzésekre és [review-zásra](https://help.github.com/articles/about-pull-request-reviews/). Csak a lefordítható, teszteknek megfelelő, ütközés (conflict) mentes PR kerülhet elfogadásra! -->
<p><strong>Fontos</strong>: Ha egy Pull Request <em>nem</em> fogadható el, akkor sem kell a PR-t lezárni, lehet tovább dolgozni a forrás branchen, az új commit-okkal automatikusan frissül a PR is addig míg a teszteknek meg nem felel és elfogadásra nem került. Sőt, kifejezetten lehet <em><em>Draft</em> PR</em>* is létrehozni, jelezve, hogy a munka már tartalmaz véleményezhető elemeket, de még nincs kész. </p>
<p>Ha a PR el lett fogadva, a feature branch-re nincs már tovább szükség. Le lehet törölni és be kell zárni azt az <em>issue-t</em> is, amihez a branch kapcsolódott. Tehát ideálisan minden (nem user-story és kérdés) issue-hoz készül(t) egy branch.</p>
<h3><a class="header" href="#forking" id="forking">Forking</a></h3>
<p>A tárgyhoz nem lesz szükség forkok használatára, de a GitHub workflow szerves részét képezi (különösen nyílt forrású projekteknél) így érdemes lehet ismerni.</p>
<ul>
<li><a href="https://www.gitprime.com/the-definitive-guide-to-forks-and-branches-in-git/">A <em>fork</em> és a <em>branch</em> közötti különbségekről</a></li>
<li><a href="https://www.atlassian.com/blog/git/git-branching-and-forking-in-the-enterprise-why-fork">Git branching and forking in the enterprise: why fork?</a></li>
<li><a href="https://blog.scottlowe.org/2015/01/27/using-fork-branch-git-workflow/">Using the Fork-and-Branch Git Workflow</a></li>
<li><a href="https://stackoverflow.com/a/34343080/4737417">Stackoverflow / Forking vs. Branching in GitHub</a></li>
</ul>
<h2><a class="header" href="#review-2" id="review-2">Review</a></h2>
<p><img src="images/review_required.png" alt="review required" /></p>
<p>Erre az „add your review” szolgál. Fájlonként át lehet nézni minden módosítást, soronként kommentelni, illetve egy globális véleményt írni a PR-ről (+1, -1, -2). A comment opció semleges, nem elfogadás, de nem is elutasítás. A másik két opció elég egyértelmű. Ha változtatást kérsz, akkor addig amíg a PR forrásbranche nem módosul nem lehet újra próbálkozni a PR elfogadásával.</p>
<p><img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/review_approved.png" alt="review" /></p>
<p>Ha minden rendben, akkor el lehet fogadni a PR-et:</p>
<p><img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/mergable.png" alt="" /></p>
<p>Elfogadás után így néz ki:</p>
<p><img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/merged.png" alt="" /></p>
<p>Ezen a ponton a feature branch nem szükséges továbbá, törölhető. Persze egy ideig még visszaállítható:</p>
<p><img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/restore_branch.png" alt="" /></p>
<h2><a class="header" href="#társszerzők" id="társszerzők">Társszerzők</a></h2>
<p>A munkafolyamat alapvetően egyéni munkára van kitalálva, de legkevésbé sem tilos a <a href="https://en.wikipedia.org/wiki/Pair_programming">pair programming</a> sem. Volt, hogy Skype-os képernyő-megosztásos módszerrel dolgoztak <em>távolról</em> párban... Ilyenkor mindig felvetődik a kérdés, hogy csak az egyik kolléga nevében történhet a commit de mi van a másikkal... A GitHub <a href="https://github.com/blog/2496-commit-together-with-co-authors">bevezetett egy új funkciót</a> ennek orvoslására. Részletek <a href="https://help.github.com/articles/creating-a-commit-with-multiple-authors/">elérhetőek itt</a>.</p>
<p>Ebben az esetben a commit üzenet törzse után 2 üres sorral elválasztva kell a társszerzőket feltüntetni. Pl.:</p>
<pre><code>Commit message header

Commit message body preceded by an empty line and followed by
two empty lines and the trailer.


Co-authored-by: name &lt;name@example.com&gt;
Co-authored-by: another-name &lt;another-name@example.com&gt;&quot;
</code></pre>
<p>Ahhoz, hogy a GitHub a társszerzőt össze is tudja rendelni a felhasználói fiókjával fontos, hogy az a <code>name</code> és különösen az az <code>e-mail</code> szerepeljen, amelyet egyébként git beállításként használ!</p>
<h3><a class="header" href="#e-mail-cím-védelme" id="e-mail-cím-védelme">E-mail cím védelme</a></h3>
<p>A GH minden felhasználónak biztosít egy &quot;proxy ímélcímet&quot;, hogy titokban tarthassa a címét, ez xxxxxxx+username@users.noreply.github.com szerkezetű, ahogy xxxxxxx egy hétjegyű felhasználói azonosító. Bővebben <a href="https://docs.github.com/en/github/setting-up-and-managing-your-github-user-account/setting-your-commit-email-address#about-commit-email-addresses">itt</a>. Ezt is lehet használni, nem csak társszerzőhöz hanem saját címnek is, csak legyen konzisztens!</p>
<h1><a class="header" href="#fejlesztői-eszközök" id="fejlesztői-eszközök">Fejlesztői eszközök</a></h1>
<h1><a class="header" href="#visual-studio-code" id="visual-studio-code">Visual Studio Code</a></h1>
<p>Csak a hivatalos Microsoft féle build hajlandó együttműködni a .NET debuggerrel!</p>
<h2><a class="header" href="#editorconfig-for-vs-code" id="editorconfig-for-vs-code">EditorConfig for VS Code</a></h2>
<blockquote>
<p>This plugin attempts to override user/workspace settings with settings found in .editorconfig files.</p>
</blockquote>
<p>A formázási beállításokhoz a <a href="https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2019">MS ajánlása szerinti</a> .editorconfig fájl hozzáadásra került a projekthez.</p>
<h2><a class="header" href="#c" id="c">C#</a></h2>
<blockquote>
<ul>
<li>Lightweight development tools for .NET Core.</li>
<li>Great C# editing support, including Syntax Highlighting, IntelliSense,Go to Definition, Find All References, etc.</li>
<li>Debugging support for .NET Core (CoreCLR).
<ul>
<li>NOTE: Mono debugging is not supported. Desktop CLR debugging has limited support.</li>
</ul>
</li>
<li>Support for project.json and csproj projects on Windows, macOS and Linux.</li>
</ul>
</blockquote>
<h2><a class="header" href="#auto-using-for-c" id="auto-using-for-c">Auto-Using for C#</a></h2>
<blockquote>
<p>Auto-imports and provides intellisense for references that were not yet imported in a C# file.</p>
</blockquote>
<h2><a class="header" href="#automatikus-kódformázás" id="automatikus-kódformázás">Automatikus kódformázás</a></h2>
<p><a href="https://stackoverflow.com/questions/49500433/auto-format-c-sharp-code-in-visual-studio-code">StackOverflow://Auto format C# code In Visual Studio Code</a></p>
<h2><a class="header" href="#net-core-test" id="net-core-test">.NET Core Test</a></h2>
<p>Unit test támogatás <em>MSTest</em>, <em>xUnit</em> és <em>NUnit</em> keretrendszerekhez.</p>
<p>Ajánlott beállítások, amiket a <code>.vscode/settings.json</code> fájlban kell elhelyezni:</p>
<pre><code class="language-json">{
    &quot;dotnet-test-explorer.testProjectPath&quot;: &quot;**/*Tests.csproj&quot;,
    &quot;dotnet-test-explorer.autoWatch&quot;: true
}
</code></pre>
<!-- C# FixFormat -->
<h2><a class="header" href="#code-coverage" id="code-coverage">Code Coverage</a></h2>
<p>A tesztlefedettség számítását a <a href="https://www.nuget.org/packages/coverlet.collector/">Coverlet</a> végzi, amit a teszt projekthez adtam hozzá. Ennek riportját használja a Codecov is. 
A riportot cobertura, lcov fomátumban is legeneráltatom, előbbi a Codcov-nak, utóbbi a <a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">Coverage Gutters</a>-nak kell, amely a VS Code-on belül ad visszajelzéseket. Utóbbi beállításaiban meg kell adni, hogy a report <code>coverage.info</code> néven áll elő, ezt keresse. Illetve be kell kapcsolni a <em>statusbar</em> „Watch” gombjábal.</p>
<p>Formátumbeállítás <code>runsettings.xml</code> állományon keresztül [<a href="https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/VSTestIntegration.md">forrás</a>]:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;RunSettings&gt;
  &lt;DataCollectionRunSettings&gt;
    &lt;DataCollectors&gt;
      &lt;DataCollector friendlyName=&quot;XPlat code coverage&quot;&gt;
        &lt;Configuration&gt;
          &lt;Format&gt;lcov,cobertura&lt;/Format&gt;
        &lt;/Configuration&gt;
      &lt;/DataCollector&gt;
    &lt;/DataCollectors&gt;
  &lt;/DataCollectionRunSettings&gt;
&lt;/RunSettings&gt;
</code></pre>
<p><img src="images/coverage_gutters.png" alt="" /></p>
<!-- ## Code Style -->
<h1><a class="header" href="#intellij-rider---c" id="intellij-rider---c">IntelliJ Rider - C#</a></h1>
<p>Egyetemi e-mail címmel (<code>stud.uni-obuda.hu</code>) igényelhető egy éves hallgatói licenc az IntelliJ termékekhez, így használható a C# fejlesztéshez szánt <a href="https://www.jetbrains.com/rider/">Rider</a> is.</p>
<h2><a class="header" href="#code-style" id="code-style">Code Style</a></h2>
<p>https://www.nuget.org/packages/StyleCop.Analyzers/</p>
<h2><a class="header" href="#save-actions-reborn" id="save-actions-reborn">Save Actions Reborn</a></h2>
<p>Ezzel automatizálni lehet a Reformat Code meghívásást.</p>
<h2><a class="header" href="#code-coverage-1" id="code-coverage-1">Code Coverage</a></h2>
<ul>
<li><a href="https://www.jetbrains.com/dotcover/">dotCover</a></li>
<li>része a Ridernek</li>
<li>aktiválás: Unit Tests fül, Run (zöld háromszög) rejtett menü / Cover Selected Unit Tests</li>
</ul>
<p><img src="images/dotcover.png" alt="" /></p>
<h1><a class="header" href="#intellij-idea---java" id="intellij-idea---java">IntelliJ IDEA - Java</a></h1>
<!-- toc -->
<p>A feladat Java nyelvű megoldásához ajánlott és támogatott fejlesztői környezet az <a href="https://www.jetbrains.com/idea/#chooseYourEdition">IntelliJ IDEA</a>. A Community Edition ingyenes, ez tartalmaz mindent amire szükség lehet a félév során.Egyetemi e-mail címmel elvileg ingyen igényelhető Pro verzió.</p>
<h2><a class="header" href="#kódformázás" id="kódformázás">Kódformázás</a></h2>
<p>IDEA beállításai alapértelmezetten elvileg megfelelnek az elvárásoknak, így egy fájl befejezése után (de értelem szerűen commit előtt) célszerű egy formázást megejteni: Code &gt; Reformat Code (CTRL+ALT+L)</p>
<ul>
<li>A behúzás beállítása: File &gt; Settings &gt; Editor &gt; Code Style &gt; Java &gt; Tabs and Indents: nem tab, de 4 karakternyi</li>
<li>A sorhossz beállítása: File &gt; Settings &gt; Editor &gt; Code Style &gt; Default Options &gt; Right magin (columns) 120 kell, hogy legyen eredetileg</li>
<li>Emellett default beállításokban a vessző és kettőspont utáni szóközök, illetve az operátorokat körbevevő szóközök is szerepelnek. Továbbá a kapcsos zárójelek használata is az elvártnak megfelelően van beállítva.</li>
</ul>
<p><a href="java_style_guide.html">Java kódformázási előírások</a></p>
<h2><a class="header" href="#save-actions" id="save-actions">Save actions</a></h2>
<p>Mivel a <em>Reformat Code</em> nyomogatását az ember hajlamos elfelejteni, létezik egy IDEA bővítmény a probléma automatizálására. Ez nem más mint a <a href="https://plugins.jetbrains.com/plugin/7642-save-actions">Save Actions plugin</a>, mely lehetővé teszi, hogy az amúgy is használt <strong>mentés</strong> (CTRL+S) parancshoz lehessen kötni a kódformázási műveletet.
A <em>Save Actions</em> plugin konfigurálását az alábbiak szerint kell megejteni.
<img src="https://user-images.githubusercontent.com/3854784/37599751-c35c06c6-2b85-11e8-8018-a8a07c1c1aa7.png" alt="idea_save_action" /></p>
<p>Zárójeles megjegyzés, hogy ez akkor fog tisztességesen működni, ha az IDEA kódformázási előírásai megfelelően vannak beállítva, vagy legrosszabb esetben default-on lett hagyva minden (már akkor is képes megszüntetni a Checkstyle-ben rögzített problémák jelentős részét).</p>
<p><a href="https://stackoverflow.com/a/28748557/4737417"><em>forrás</em></a></p>
<h2><a class="header" href="#checkstyle-plugin" id="checkstyle-plugin">Checkstyle plugin</a></h2>
<p>A Checkstyle egy statikus kódelemző szoftver Java nyelvhez, amely egyrészt a kódformázási előírások betartását, másrészt egyéb programozástechnikai előírások betartását is ellenőrzi.</p>
<p><a href="https://plugins.jetbrains.com/plugin/1065-checkstyle-idea">Checkstyle plugin</a> beállítása IntelliJ IDEA környezetbe. A plugin telepíthető a plugin managerből majd a következő beállításokra van szükség:</p>
<p>File &gt; Settings &gt; Other Settings &gt; Checkstyle &gt; Configuration File panelen <em>Add</em> és a projekt gyökérben megtalálható <code>checkstyle.xml</code> fájlt kell neki megadni (és elnevezni valamiként, az alábbi képen <code>szfmv</code>). Innentől a fejlesztői környezeten belül elérhető a kódminőség-ellenőrzés <em>valós időben</em>, warning-okkal jelzi a találatokat.</p>
<p><img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/idea_checkstyle_plugin_settings.png" alt="" />
<img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/idea_checkstyle_findings.png" alt="" /></p>
<h2><a class="header" href="#tesztlefedettség-1" id="tesztlefedettség-1">Tesztlefedettség</a></h2>
<p>A kód „minőség” egy mérőszáma lehet, hogy mekkora része van (unit)tesztekkel lefedve. Ezt a projekt README-ben a <a href="https://coveralls.io/github/SzFMV2017-Tavasz/AutomatedCar?branch=master">Coveralls.io</a> szolgáltatás folyamatosan meg is jeleníti.</p>
<p>Ehhez a <a href="http://www.eclemma.org/jacoco/">JaCoCo</a>-t használjuk, ami Maven-en keresztül (a <code>pom.xml</code>-ben) lett beállítva. A kód tesztekkel történő lefedettségének megjelenítéséhez a fejlesztői környezetek mindenféle okos eszközöket is rendelkezésre bocsátanak.</p>
<p>Az IntelliJ IDEA-ban beépített megoldás is van, illetve olyan külső eszközöket is képes használni mint a JaCoCo. Képes arra, hogy színkódokkal megfesse az egyes metódusokat annak megfelelően, hogy van-e hozzá teszt.</p>
<p>A <a href="https://www.jetbrains.com/help/idea/2016.3/code-coverage.html">beállításához</a> meg kell nyitni a <a href="https://www.jetbrains.com/help/idea/2016.3/creating-and-editing-run-debug-configurations.html">Run/debug configuration</a> ablakot, majd a <em>Code Coverage</em> fülön kiválasztani az IntelliJ IDEA-t vagy a JaCoCo-t, előbbi Tracing típusú vizsgálatot is tud (ami jelenleg mindegy). Ezután a <em>Run</em> menü <em>Run 'Main' with Coverage</em> menüpontjával a kódot úgy futtatja, hogy a számításokat el is végzi és megjeleníti az összesítő panelt.</p>
<p>Az IDEA-n kívül más IDE-khez is megtalálhatóak hasonló funkciók: <a href="http://wiki.netbeans.org/MavenCodeCoverage">NetBeans</a>, <a href="http://www.eclemma.org/jacoco/">Eclipse</a></p>
<h3><a class="header" href="#képernyőképek" id="képernyőképek">Képernyőképek</a></h3>
<p><img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/idea_run_debug_config_menu.png" alt="" />
<img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/idea_run_debug_config_window.png" alt="" />
<img src="https://raw.githubusercontent.com/SzFMV2018-Osz/handout/master/docs/images/idea_coverage_window.png" alt="" /></p>
<h2><a class="header" href="#logolás---log4j" id="logolás---log4j">Logolás - Log4J</a></h2>
<p>Módfelett udvariatlan, káros és így kerülendő hibakeresési céllal a standard kimenetre (<code>System.out.println</code>) írni. Ettől még sokan megteszik mondván addig nincs baj, míg nem kerül pusholásra a közös repóba. Csakhogy a kódolás hevében könnyen ott felejthet az ember egy-két ilyet, így célszerű eleve bele sem tenni!</p>
<p>Szerencsére több logger is létezik, amik nem csak a <code>System.out.println</code> nem rendeltetés szerű használatát tudják megakadályozni, de bónuszként még egy halom hasznos és kényelmes funkcióval is rendelkeznek. A projektben az <a href="https://logging.apache.org/log4j/2.x/">Apache log4j 2.8</a>-as verziója került bevezetésre.</p>
<h2><a class="header" href="#konfigurálás" id="konfigurálás">Konfigurálás</a></h2>
<p>A logolási beállítások egyrészt helyzetfüggőek, másrészt a fejlesztő magánügyét képezik, így nem kényszerítjük rá a másikra a kedvenc beállításainkat. Ebből következik, hogy a <code>log4j2.xml</code> konfigurációs állomány nincs a <em>git</em> verziókezelő felügyelete alatt. Példa a tartalmára [<a href="http://stackoverflow.com/a/21206994/4737417">forrás</a>]:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;INFO&quot;&gt;
    &lt;Appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; /&gt;
        &lt;/Console&gt;
        &lt;!--&lt;File name=&quot;MyFile&quot; fileName=&quot;all.log&quot; immediateFlush=&quot;true&quot; append=&quot;false&quot;&gt;--&gt;
            &lt;!--&lt;PatternLayout pattern=&quot;%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;--&gt;
        &lt;!--&lt;/File&gt;--&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;Root level=&quot;debug&quot;&gt;
            &lt;AppenderRef ref=&quot;Console&quot; /&gt;
            &lt;!--&lt;AppenderRef ref=&quot;MyFile&quot;/&gt;--&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>A fenti fájlt a projektmappába pl. a <code>src/main/resources/</code>-be kell elhelyezni. Jelenlegi beállításokkal <strong>DEBUG</strong> szintű, fájlba nem ment, csupán a fejlesztői környezet konzoljára ír. A fenti fájl hiányában <strong>ERROR</strong> beállításokkal fog működni.</p>
<h3><a class="header" href="#szintek" id="szintek">Szintek</a></h3>
<p>A logolásnak több szintje van attól függően, hogy milyen finomságú részletekre vagyunk kíváncsiak. Ezek a szintek sorban (a legbővebbtől a legszűkebbig): ALL, TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF. Ebből következik, hogy egy <em>INFO</em> szintű log üzenet meg fog jelenni <em>DEBUG</em> beállítások mellett, de nem fog megjelenni <em>ERROR</em> beállításokkal.</p>
<h3><a class="header" href="#példa-a-használatára" id="példa-a-használatára">Példa a használatára</a></h3>
<pre><code class="language-java">package hu.oe.nik.automatedcar.demo;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Demo {
  private static final Logger LOGGER = LogManager.getLogger();

  public void demo(){
    LOGGER.debug(&quot;Ez egy debug szintű üzenet&quot;);
    LOGGER.error(&quot;Ez egy error szintű üzenet&quot;);
  }
}
</code></pre>
<h3><a class="header" href="#további-leírás" id="további-leírás">További leírás</a></h3>
<ul>
<li><a href="http://howtodoinjava.com/log4j2/log4j-2-xml-configuration-example/">Log4j2 xml configuration example</a></li>
</ul>
<h2><a class="header" href="#maven-és-a-proxy" id="maven-és-a-proxy">Maven és a proxy</a></h2>
<p>Ha valaki céges gépen dolgozik előírt proxy mellett, érdemes figyelni arra, hogy <a href="https://maven.apache.org/guides/mini/guide-proxies.html">a maven-nek külön kell konfigurálni a proxy-t</a>.</p>
<h2><a class="header" href="#függőségeket-tartalmazó-futtatható-jar-állomány-létrehozása" id="függőségeket-tartalmazó-futtatható-jar-állomány-létrehozása">Függőségeket tartalmazó futtatható <code>.jar</code> állomány létrehozása</a></h2>
<pre><code>mvn clean compile assembly:single
</code></pre>
<p>Az eredmény a <code>target/AutomatedCar-jar-with-dependencies.jar</code></p>
<h1><a class="header" href="#kódformázás-1" id="kódformázás-1">Kódformázás</a></h1>
<p><img src="https://www.explainxkcd.com/wiki/images/c/c6/code_quality.png" alt="Code quality" /></p>
<p>A kód tisztasága, olvashatósága nem csak szemantikai, de szintaktikai értelemben is fontos. Minden nyelvnek megvannak a maga „nyelvtani”, szintaktikai előírásai, amit a fordító be is tartat. Azonban ezen túl megvannak azok az (íratlan) szabályai is, amiket már nem a fordító feladata betartatni. (A Go fordítónál ez kezd egybemosódni, pl. nem fordul a kód ha van deklarált, de fel nem használt változód, a <a href="https://golang.org/cmd/gofmt/">gofmt, Go format</a> pedig kikényszeríti a kódformázási szabályokat.)</p>
<p>Ezek olyan kódformázási szabályok, amelyek több szinten lehetnek definiálva. Egyrészt (többé-kevésbé) egyezményesen egy-egy nyelv szintjén (pl. <a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a> Python esetében, gofmt), aztán lehetnek vállalati esetleg osztály és projekt szinten is.
Például a <a href="https://01.org/linuxgraphics/gfx-docs/drm/process/coding-style.html">Linux kernelkez tartozó előírások</a> - többek között - 8 szóköznyi behúzást írnak elő és maximum 80 karakter széles sorokat. A gondolat emögött, hogy maximum három blokk mélységű szerkezet fogadható el, amikor is már a sor 30%-át teszi ki a behúzás. Ennél több behúzás esetén már nem sok hely marad a kódnak.</p>
<p>A Java nyelvhez is van(nak) kódformázási előírás(ok), amelyek egy része teljesen általános. Pl. a csomagnevek kisbetűsek, az osztály nevek mindig nagybetűvel kezdődnek (a fejlesztői környezetek ezt például általánosan számon kérik), a metódusnevek pedig kis betűvel kezdődnek továbbá a szóösszetételeknél nagybetűket használunk pl. <code>metódusNév</code>.</p>
<p>Átfogó ajánlást készített még 2000 környékén a Sun, ám ez mára meglehetősen túlhaladott, vagy ilyen a Google által összeállított <a href="https://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a>.
Ez viszont helyenként túl specifikus (nagyvállalati környezetre optimalizált) a tárgy kereteihez, így nem egy az egyben ezt használjuk. A <a href="http://checkstyle.sourceforge.net/">Checkstyle</a> statikus kódanalizátor default értékei vagy a Jetbrains által az IntelliJ IDEA-ba beállított default szabályok is felfoghatók egy ilyen ajánlásnak.</p>
<p>A C#-hoz a Microsoft definiálta a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions">kódformázási szabályokat</a>, ezeket kell követni a tárgy során is.</p>
<h1><a class="header" href="#statikus-program-analízis" id="statikus-program-analízis">Statikus program analízis</a></h1>
<p>A statikus analízis során a programkód végrehajtása nélkül, többnyire a forráskód elemzésével - automatizáltan - történik kód hibáinak feltárása.[<a href="https://en.wikipedia.org/wiki/Static_program_analysis">Wikipédia</a>]
Ilyen eszköz Java nyelvhez például a nyílt forrású <a href="https://pmd.github.io/">PMD</a>, vagy a <a href="http://checkstyle.sourceforge.net/">Checkstyle</a>.</p>
<p>A kurzus során az utóbbit használjuk, amely figyeli a fentebb leírt formázási ajánlásokat (<a href="http://checkstyle.sourceforge.net/checks.html">teljes használható szabálylista</a>). Ezen túlmenőleg egyéb hibafaktorokat is figyel: magic number-ek alkalmazása, string literál többszöri előfordulása, <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Ciklomatikus komplexitás</a>, túl sok paraméter a metódusban (5), túl hosszú metódus (20 utasítás), túl hosszú sor (120 karakter) valamint a kódban felejtett <code>TODO</code> és <code>FIXME</code> kommentekre is érzékeny.</p>
<p>A master repók (<a href="https://github.com/SzFMV2018-Osz/AutomatedCar-A">A</a> és <a href="https://github.com/SzFMV2018-Osz/AutomatedCar-B">B</a>) össze lett drótozva a <a href="https://www.codefactor.io">CodaFactorral</a> és folyamatosan méri a kód minőségét, valamint egy A-tól F-ig tartó skálán <a href="https://support.codefactor.io/i14-glossary">osztályozza</a> is (ahol az A a legjobb).</p>
<h1><a class="header" href="#c-1" id="c-1">C#</a></h1>
<h1><a class="header" href="#kódformázási-előírások-java-nyelvhez" id="kódformázási-előírások-java-nyelvhez">Kódformázási előírások Java nyelvhez</a></h1>
<p>„Örök kérdés”, hogy szóközök vagy tabok jelöljék-e a behúzást. Ma már minden normális editor beállítható úgyis, hogy a tab billentyű szóközöket szúrjon be, amelyik erre (sem) képest azt meg nem használjuk. A kérdés, legalábbis ezen tárgy keretein belül azzal zárult, hogy <em>mindenki</em> szóközöket használ, tabok nem lehetnek a fájlban. Pont.
Egy rövid (nem túl komoly) videó a témában: <a href="https://youtu.be/SsoOG6ZeyUI">Silicon Valley - S03E06</a></p>
<ul>
<li>a behúzást 4 szóköz jelöli (nincs tab a fájlban)</li>
<li>nem lehetnek üres blokkok</li>
<li>a nyitó kapcsos zárójel a sor végén található</li>
</ul>
<pre><code class="language-java">if (condition) {
    ...
}
</code></pre>
<ul>
<li>a záró kapcsos zárójel kulcsszavakkal azonos sorba helyezendő</li>
</ul>
<pre><code class="language-java">try {
    ...
} catch (Exception ex) {
    ...
} finally {
    ...
}
</code></pre>
<ul>
<li>minden esetben ki kell tenni a blokkjelölő kapcsos zárójeleket</li>
<li>osztályon belül meghatározott sorrendben szerepelnek az elemek
<ol>
<li>Class (static) variables. First the public class variables, then protected, then package level (no access modifier), and then private.</li>
<li>Instance variables. First the public class variables, then protected, then package level (no access modifier), and then private.</li>
<li>Constructors</li>
<li>Methods</li>
</ol>
</li>
<li>kerülendő az üres utasítás (<code>;</code>)</li>
<li>mindig szükséges default ág a swith-case szerkezetben</li>
<li>soronként egy utasítás szerepel</li>
<li>kerülendő a <code>return</code> kulcsszavak halmozása egy metóduson belül</li>
<li>kerülendőek a *-os importálások</li>
<li>kerülendő a nem használt importálás</li>
<li>az osztály neve megegyezik a fájl nevével</li>
<li>az operátorok körül, valamint a vessző és kettőspont után szóköz kerül</li>
</ul>
<h2><a class="header" href="#kulcsszó-sorrend" id="kulcsszó-sorrend">Kulcsszó sorrend</a></h2>
<p>A Javában a metódusok különböző módosítókkal láthatók el mint <code>static</code>, <code>public|private|protected</code>, <code>final</code> ám ezeknek előírt sorrendje is van. Nem a fordító írja elő sajnos, tehát lefordul, de konvenció, hogy ezeket milyen sorrendbe tesszük. Pl. a teljesség igénye nélkül  <code>public static</code> oké <code>static public</code> nem.
Sajnos a <em>Reformat Code</em> ezt nem rázza gatyába, így az automatizált megoldás sem fogja, de ettől még stílus hiba.</p>
<p>Javítani lehet a helyzeten a File | Settings | Editor | Inspections | Java | Code style issues | Missorted modifiers inspection bepipálásával <strong>ÉS</strong> az Analyze | Code Cleanup <em>commit előtti</em> alkalmazásával. Sajnálatos módon a Save Actions ezt nem tudja. :sob:</p>
<p><a href="https://stackoverflow.com/a/31203757/4737417"><em>forrás</em></a></p>
<h2><a class="header" href="#javadoc" id="javadoc">Javadoc</a></h2>
<blockquote>
<p>Javadoc is a tool which comes with JDK and it is used for generating Java code documentation in HTML format from Java source code, which requires documentation in a predefined format.</p>
<p><a href="https://www.tutorialspoint.com/java/java_documentation.htm">tutorialspoint / Java - Documentation Comments</a></p>
</blockquote>
<p>Tutorials:</p>
<ul>
<li><a href="https://www.tutorialspoint.com/java/java_documentation.htm">tutorialspoint</a></li>
<li><a href="https://www.baeldung.com/javadoc">baeldung.com/javadoc</a></li>
</ul>
<h1><a class="header" href="#munkafolyamat" id="munkafolyamat">Munkafolyamat</a></h1>
<p>Definiáltunk egy munkafolyamatot, amely követése elvárás a félév során.
A munkafolyamat alapvetően feltételezi, hogy egy adott kódrészletet egy kolléga ír, de legkevésbé sem tilos a <a href="https://en.wikipedia.org/wiki/Pair_programming">pair programming</a> sem. Ahhoz, hogy a GitHub rögzítse a mindkét kollégát, a társszerzőt meg kell jelölni. Erről <a href="git.html#t%C3%A1rsszerz%C5%91k">itt lehet olvasni</a>.</p>
<p>A konkrét feladatmegoldáshoz az alábbi folyamat az elvárt:</p>
<p><img src="images/proc1.png" alt="" /></p>
<ul>
<li>User Story:
<ul>
<li>high level description of sprint goal by customer not complete! Never detailed enough!</li>
</ul>
</li>
<li>Component Design:
<ul>
<li>what will realize the functions in the user story You have to recognize the (hidden?) functionality!</li>
</ul>
</li>
<li>Requirement Specification:
<ul>
<li>what makes the component work as expected basically the Definition of Done for the component</li>
</ul>
</li>
<li>Task Definition:
<ul>
<li>add milestone (there is one for every sprint) to issue</li>
<li>add assignee to issue</li>
<li>add Definition of Done list to issue</li>
<li>add project (there is one for every team) to issue</li>
</ul>
</li>
</ul>
<p><img src="images/proc2.png" alt="" /></p>
<ul>
<li>Dod: Definition of Done</li>
</ul>
<h2><a class="header" href="#code-review-in-details" id="code-review-in-details">Code Review in details</a></h2>
<p><img src="images/proc3.png" alt="" /></p>
<ul>
<li>Clean Code:
<ul>
<li>no magic numbers</li>
<li>no abbreviations</li>
<li>no extreme unit lengths</li>
<li>talkative names</li>
<li>unambiguous code</li>
</ul>
</li>
<li>in short:
<ul>
<li>Easy to understand and maintain</li>
<li>Reads like well written prose</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#vállalati-példa" id="vállalati-példa">Vállalati példa</a></h1>
<p>A munkakultúráról egy remek videót tett közzé a Spotify, <a href="https://labs.spotify.com/2014/03/27/spotify-engineering-culture-part-1/">megtekinthető itt</a>.</p>
<h1><a class="header" href="#implementáció" id="implementáció">Implementáció</a></h1>
<!-- toc -->
<h2><a class="header" href="#c-2" id="c-2">C#</a></h2>
<p>A korábbi félévek visszajelzései visszetérő eleme volt, hogy C#-ban is meg lehessen oldani a feladatot. A cross-plastform fejleszés ugyan feltétel, így „csak” a <a href="https://dotnet.microsoft.com/download/dotnet-core">.NET Core</a> jöhet szóba, ennek is a 3.1-es verziója (LTS).</p>
<p>A .NET 5 egyesíti majd a .NET Framework-öt és a .NET Core továbbá bevezeti a MAUI-t mint multiplatform keretrendszert grafikus felületek készítéséhez, ez azonban ma még <a href="https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/">nem elérhető</a>.</p>
<p>Addig is szükség volt egy áthidaló megoldásra miután a WPF nem használható Windows-on kívül, erre a <em>3rd party</em> <a href="http://avaloniaui.net/">Avalonia</a> keretrendszert fogjuk használni. Az Avalonia a WPF-hez hasonlóan egy XAML alapú Model-View-ViewModel (MVVM) rendszer.</p>
<p><img src="images/dotnet_stack.png" alt=".NET stack" /></p>
<p>Használható fejlesztői környezetek: Visual Studio, VS Code (kizárólag a hivatalos, MS változattal működik együtt a .NET debugger), IntelliJ Rider, stb.</p>
<h2><a class="header" href="#java" id="java">Java</a></h2>
<p>A feladat megoldásához Java nyelvet, annak is a 11-es verzióját kell használni (LTS), <a href="https://maven.apache.org/guides/getting-started/index.html">Maven</a> projekt menedzsment eszközzel. (A kiinduló projekt ezeket már teljesíti). Egyaránt használható az <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html">Oracle JDK 11</a> vagy az <a href="http://openjdk.java.net/projects/jdk/11/">OpenJDK 11</a> is, operációs rendszer sincs megszabva.
Az automatizált CI eszközök jogi okokból az OpenJDK-t használják, linuxon. Szóval már csak emiatt is „érdemes” platformfüggetlen kódot írni!</p>
<p>A kiadott kód csak példa egy alap GUI készítésére Swing-el, ez akár teljesen átírható, más GUI könyvtárak (pl. JavaFx) is használható.
Viszont az IntelliJ IDEA GUI Designer-e <em>nem</em> használható, esetleges kompatiblitási okoból.</p>
<p>Hasznos írások az implementációhoz:</p>
<ul>
<li><a href="https://gamedev.stackexchange.com/questions/56017/java-best-implementation-keylistener-for-games">Billentyű/input kezelés</a></li>
<li><a href="https://web.archive.org/web/20190403012130/https://gafferongames.com/post/fix_your_timestep/">Időzítés</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">Villódzásmentes rajzolás</a></li>
</ul>
<h1><a class="header" href="#virtuális-világ" id="virtuális-világ">Virtuális világ</a></h1>
<p>Az autónak egy virtuális tesztpályán kell végigmennie, amelyhez modellezni a világot. Két teszt pályát biztosítunk, egy egyszerűbbet és egy nagyobbat, bonyolultabbat. Alább látható az egyszerűbb.</p>
<p><img src="images/test_world.png" alt="" /></p>
<p>A fenti világ elemekből épül föl, amelyek között vannak egyenes útszakaszok, kanyarok (pl. 45° és 90°), T elágazás, gyalogos átkelő, közúti táblák, parkolók és fák. Mindezt <a href="resources/test_world.xml">egy XML</a>, vagy <a href="resources/test_world.json">egy JSON</a> írja le. A feladat megoldásához bármelyik formátum használható.</p>
<p>A számítógépes grafikában megszokott módon, a bal felső sarok jelenti az origót (0,0) koordinátát. Az x tengely tehát jobbra haladva, az y tengely lefelé haladva növekszik. Így kell értelmezni az XML-t és ekképpen működik a megjelenítés is, hiszen a form bal felső sarkánál van a (0, 0) pont. Az alábbi kép <a href="http://www.e-cartouche.ch/content_reg/cartouche/graphics/en/html/Screen_learningObject3.html">forrása</a>.</p>
<p><img src="http://www.e-cartouche.ch/content_reg/cartouche/graphics/en/image/coordinates.jpg" alt="" /></p>
<h2><a class="header" href="#objektumok-leírása" id="objektumok-leírása">Objektumok leírása</a></h2>
<p>Egy-egy objektum leírása a következőképpen néz ki (XML-ben):</p>
<pre><code class="language-xml">&lt;Object type=&quot;road_2lane_straight&quot;&gt;
      &lt;Position x=&quot;1700&quot; y=&quot;144&quot;/&gt;
      &lt;Transform m11=&quot;0&quot; m12=&quot;1&quot; m21=&quot;-1&quot; m22=&quot;0&quot;/&gt;
      &lt;Parameter name=&quot;roadpainting_1&quot; value=&quot;1&quot;/&gt;
      &lt;Parameter name=&quot;roadpainting_2&quot; value=&quot;1&quot;/&gt;
      &lt;Parameter name=&quot;roadpainting_3&quot; value=&quot;1&quot;/&gt;
&lt;/Object&gt;
</code></pre>
<ul>
<li>A <code>type</code> attribútum írja le, hogy milyen objektumról van szó. A példában egy 2 sávos egyenes útszakaszról.</li>
<li>A <code>Position</code> elem megadja az elem viszonyítási pontjának koordinátáját.</li>
<li>A <code>Transform</code> elem egy 2×2-es transzformációs mátrix, amely forgatást ír le.</li>
<li>A <code>roadpainting</code> megadná, hogy milyen felfestések vannak vannak az úton, de ez nem releváns</li>
<li>Egy ilyen egyenes útelem 350×350px, ekkora a kép is és ennek kell lennie az XML-ben is.</li>
</ul>
<h2><a class="header" href="#az-út-elemek-viszonyítási-pontjai" id="az-út-elemek-viszonyítási-pontjai">Az út elemek viszonyítási pontjai</a></h2>
<p>A képfájlok amikkel a rajzoló csapat dolgozik elég sajátosan működnek. A transzformációs mátrixban leírt elforgatás pl. nem a bal felső sarokkal van értelmezve, hanem elemenként más és más ponttal. Ezek rögzítése szükséges lehet a modellben, a rajzoló csapat munkáját megkönnyítendő. Egyébként korábbi félévekben ezt már összeszedték <a href="resources/reference_points.xml">egzakt módon is</a>.</p>
<p><img src="images/90right.png" alt="" /> <img src="images/90left.png" alt="" /></p>
<p><img src="images/45right.png" alt="" /> <img src="images/45left.png" alt="" /></p>
<p><img src="images/6right.png" alt="" /> <img src="images/6left.png" alt="" /></p>
<p><img src="images/tjunctionright.png" alt="" />
<img src="images/tjunctionleft.png" alt="" /></p>
<p><img src="images/straight.png" alt="" />
<img src="images/rotary.png" alt="" /></p>
<p><img src="images/2_crossroad_1.png" alt="2_crossroad_1" />
<img src="images/2_crossroad_2.png" alt="2_crossroad_2" /></p>
<p>Minden itt fel nem sorolt esetben feltételezhető, hogy a bal felső sarok a viszonyítási pont.</p>
<p>Egy korábbi félév során a referenciapontokat (részben) már összegyűjtötték (@csabalint, @SiposGergo, @markkurucz), ez elérhető <a href="resources/reference_points.xml">XML</a> vagy <a href="resources/reference_points.json">JSON</a> formátumban.</p>
<p>A mozgatásra szoruló elemek (vezérelt autó és NPC autók) nem képezik részét a világ leírásának, viszonyítási pontjuk nem definiált. A rendelkezésre bocsátott autó képek méretarányosak az összes többi objektummal.</p>
<p>A világhoz szükséges elemek megtalálhatóak a kiinduló project <code>src/main/resources</code> (Java) vagy <code>src/AutomatedCat/Assets</code> (C#) mappájában.</p>
<h2><a class="header" href="#méretarány" id="méretarány">Méretarány</a></h2>
<p>Az XML-ben leírt objektumok koordináta-rendszere nem feltétlenül egyezik meg a megjelenítő koordináta-rendszerével, ezt figyelembe véve skálázás, vagy viewport kezelés válhat szükségessé.</p>
<p>A feladat megoldás során jellemzően valóságos mértékegységekben specifikáljuk a feladatot (pl. méter, km/h, m/s^2, stb.) míg az XML és a grafikai elemek értelem szerűen pixellel dolgoznak. Ennek feloldására, illetve az átváltásra az <strong>1m=50px</strong> szabályt célszerű használni. Ez egy hozzávetőlegesen arányos érték, amellyel számolni is könnyű.</p>
<!--## Sávtartó automatika tesztelése

A sávtartó automatika nem tesztelhető kanyarokban, ehhez ezért egy alább látható kinézetű pályaszakasz készült. Csak 6°-os és egyenes útszakaszból áll. [Az XML elérhető itt](resources/lane_keeping_test_world.xml).

![](images/lka_track.png)
--><h1><a class="header" href="#az-autó-fizikája" id="az-autó-fizikája">Az autó fizikája</a></h1>
<p>Az autónak egy leegyszerűsített modellen keresztül ugyan, de mégis valóságosan kell viselkednie, ehhez pedig megfelelő fizikát kell leprogramozni. Az haladásához nyilván <em>sebességre</em> lesz szükség, amit a <em>motorerő</em> gyorsító ereje segítségével kaphatunk, és ami a gázpedál(t helyettesítő billentyű) elengedésével <em>nem szűnik meg azonnal</em>, tehát ha úgy tetszik lendületben marad, viszont a környezet (légellenállás, súrlódás) fokozatosan <em>fékezi</em> (akár egyetlen lassító erő is elegendő). Nem kell az egész univerzumot szimulálni, de legalább egy gyorsító és egy fékező erő például biztosan szükséges lesz.</p>
<p>Ezen jelenségeket (és még sok minden mást) egy autós játék fizikájáról Marco Monster szépen összefoglalta <a href="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html">Car Physics for Games</a> című írásában (angol nyelven).</p>
<p>Szintén hasznos lehet még <a href="http://www.iforce2d.net/b2dtut/top-down-car">ezen írás</a> is, természetesen továbbra is angol nyelven, vagy tetszőleges egyéb irodalom (hint: Google, Stackoverflow, Wikipedia).</p>
<p>Az autóhoz <a href="https://auto.howstuffworks.com/automatic-transmission.htm">automata váltót</a> kell megvalósítani, de az automata vátóban is vannak „belső” fokozatok (1, 2, 3, 4 stb. előremenetben), tehát meg kell különböztetni a „külső” fokozatokat (P, R, N, D) és D állapotban a belsőket.</p>
<h2><a class="header" href="#kanyarodás" id="kanyarodás">Kanyarodás</a></h2>
<ul>
<li>http://gamedev.stackexchange.com/questions/50022/typical-maximum-steering-angle-of-a-real-car</li>
<li>http://engineeringdotnet.blogspot.hu/2010/04/simple-2d-car-physics-in-games.html</li>
</ul>
<p><img src="https://i.stack.imgur.com/DQsP9.png" alt="" /></p>
<p>A fordulókör sugarának kiszámításához a fönti linkből származó képlet használható:</p>
<blockquote>
<p>atan(wheelbase / (turning circle - car width)) = angle</p>
</blockquote>
<p>A <a href="resources/car_2_white.png"><code>car_2_white.png</code></a> esetében a szélesség kb. 90px, a tengelytáv kb. 130px-nek tekinthető. Tegyük fel, hogy maximum 60°-ban kormányozható, ekkor a fordulókör sugara:</p>
<blockquote>
<ul>
<li>
<p>atan(130px / (r - 90px)) = 60°</p>
</li>
<li>
<p>tan(60) = 130/(r-90)</p>
</li>
<li>
<p>r = 130/tan(60) + 90</p>
</li>
<li>
<p>r = ~165px</p>
</li>
</ul>
</blockquote>
<p><strong>Figyelem, ezek lényegesen valósághűbb autó szimulálását tűzték ki célul mint ami itt minimálisan elvárt!</strong></p>
<h1><a class="header" href="#szenzorok" id="szenzorok">Szenzorok</a></h1>
<!-- toc -->
<p>A vezetéstámogató rendszerek 3 fő szenzorra épülnek: kamera, radar és ultrahang. A valóságban adott esetben a vezetéstámogató rendszerek több szenzor együttes használatával működnek (a szoftverben ilyet nem kell megvalósítani).</p>
<p>A jegyzetben szereplő ábrák a szenzorok látóterét nem méretarányosan mutatják mivel a radar és a kamera látótere túl nagy, így az igazán lényeges részletek elvesznének.</p>
<p>További olvasmány:</p>
<ul>
<li><a href="http://www.eetimes.com/document.asp?doc_id=1272754">Driver Assistance Systems, an introduction to Adaptive Cruise Control</a></li>
<li><a href="https://autonomous-driving.org/2019/01/25/positioning-sensors-for-autonomous-vehicles/">Sensor Set Design Patterns for Autonomous Vehicles</a></li>
</ul>
<h2><a class="header" href="#kamera" id="kamera">Kamera</a></h2>
<p>A kamera a szélvédő mögött található, 60°-os látószöggel 80 méterre lát el. A <a href="functions.html#t%C3%A1blafelismer%C5%91-traffic-sign-recognition---tsr">táblafelismerő rendszer</a> és a <a href="functions.html#s%C3%A1vtart%C3%B3-automatika-lane-keeping-assistant---lka">sávtartó automatika</a> használja.</p>
<p><img src="images/camera.png" alt="Kamera szenzor látótere, nem méretarányos" title="Kamera szenzor látótere, nem méretarányos" /></p>
<h2><a class="header" href="#radar" id="radar">Radar</a></h2>
<p>A radar az autó lökhárítóján helyezkedik el, 60°-os látószöggel 200 méterre lát el. Az <a href="functions.html#adapt%C3%ADv-tempomat-adaptive-cruise-control---acc">adaptív tempomat</a> és az <a href="functions.html#auton%C3%B3m-v%C3%A9szf%C3%A9kez%C5%91-rendszer-automatic-emergency-brake---aeb">autonóm vészfékező rendszer</a> épül rá.</p>
<p><img src="images/radar.png" alt="Radai szenzor látótere, nem méretarányos" title="Radai szenzor látótere, nem méretarányos" /></p>
<p>A valóságban a radar több járművet is azonosít. A azonos sávban közvetlenül előtte haladót, a szomszédos sávokban haladó autókat és a képes az azonos sávban haladó előttit is azonosítani (az autó alatt átverődő jelekkel). Ennek köszönhetően az olyan potenciálisan veszélyes manőverek mint a szomszéd sávból elénk bevágó autó is felismerhető mivel folyamatosan figyeli ezek helyzetét.</p>
<p><img src="images/radar_lanes.png" alt="" /></p>
<h2><a class="header" href="#ultrahang" id="ultrahang">Ultrahang</a></h2>
<p>Az ultrahang szenzorból 8 darab van az autón, látótávolsága 3 méter, látószöge 100°, a <a href="functions.html#parkol%C3%B3-asszisztens-parking-pilot---pp">parkoló asszisztens</a> és a <a href="functions.html#tolat%C3%B3radar">tolatóradar</a> épül rá.</p>
<p><img src="images/ultrasonic.png" alt="Ultrahang szenzorok látóterei" title="Ultrahang szenzorok látóterei" /></p>
<h1><a class="header" href="#szenzorimplementáció-működése" id="szenzorimplementáció-működése">Szenzorimplementáció működése</a></h1>
<p>A valóságos szenzorokhoz képest az implemtálandó szenzorok jelentősen egyszerűbbek. Értelem szerűen nem kell sem radar, sem ultrahang jeleket szimulálni és a szenzorok látóterét is jelentősen egyszerűsítve reprezentáljuk: egy háromszöggel.</p>
<p><img src="images/sensor_dataflow.png" alt="" /></p>
<p>A szenzor látóterét jelképező háromszög a vezérelt autóhoz van rögzítve, vele együtt mozog. Ez az a háromszög amely kijelöli a világ egy szeletét és elérhetővé teszi a szenzornak feldolgozásra. Maga a világ (World osztály) singleton, pontosan egy létezik belőle amelyhez bármely szenzor közvetlenül hozzáfér.</p>
<p>A világ tartalmaz egy WorldObject objektumokból álló gyűjteményt, amelyben minden statikus és dinamikus objektum megtalálható, beleértve a vezérelt autót is.</p>
<p>Az első sprint során a modellező csapat implementál egy lekérdező metódust, amely egy háromszöget (vagy 3 pontot) vár bemenetként és visszadja azon világ objektumok listáját, amelyek beleesnek ebbe a háromszögbe.</p>
<p>Ha a szenzor háromszög ugyanolyan poligonnal van megvalósítva mint a világobjektumok poligonjai, akkor az <code>intersects</code> metódussal könynen eldöntehető, hogy a szenzor látóterének háromszövgébe tartozik-e egy-egy világ objektum.</p>
<p><img src="images/sensor_dataflow_2.png" alt="" /></p>
<p>A szenzorok ez a listát tovább szűrik az alapján, hogy mire érzékenyek. A kamerára a sávtartóautomatika (LKA) és a táblafelismerő (TSR) épül, így annak a szenzornak az útelemek és a táblák relevánsak.</p>
<p>A radar és az ultrahang olyan objektumokra érzékeny, amelynek neki lehet menni, amivel az egocar ütközhet. Ezen kívül a radarra épülő ACC a vezérelt autó előtt (sávon belül) haladó autóra fókuszál, a vészfékező (AEB) bármire ami az egocar útjába esik. Az ultrahang szenzor szintén, csupán az rövidebb távon és a Parking Pilot használja.</p>
<p>Miután a szenzorokhoz konkrét objektum referenciák kerülnek, a szenzor hozzáfér az objektum minden tulajdonságához. Így akár könnyedén lehet számítani távolságot két objektum között (a referenciapontok segítségével).</p>
<p><img src="images/sensor_dataflow_3.png" alt="" /></p>
<p>A szenzorok a feldolgozásuk eredményét a <em>Virtual Function Bus</em>-ra írják <em>packet</em> objektumok segítségével. Aztán ezeket a megfelelő modulok kiolvassák és hasznosítják. Pl. a műszerfalon megjelenik a táblafelismerő által detektált tábla, vagy az AEB által generált vezérlésre a hajtáslánc modul fékezéssel reagál.</p>
<h1><a class="header" href="#vezetéstámogató-funkciók" id="vezetéstámogató-funkciók">Vezetéstámogató funkciók</a></h1>
<h2><a class="header" href="#adaptív-tempomat-adaptive-cruise-control---acc" id="adaptív-tempomat-adaptive-cruise-control---acc">Adaptív tempomat (Adaptive Cruise Control - ACC)</a></h2>
<blockquote>
<p>Az adaptív sebességtartó automatika a hagyományos tempomat továbbfejlesztett változata. Az ACC egy rendkívül precíz radarral, valamint a gázadás és a fékezés elektronikus vezérlésével tartja az előre beállított követési távolságot. Ha a két jármű között csökken a távolság, az ACC mérsékli a sebességet, sőt szükség esetén fékez is, közben pedig aktiválja a féklámpákat. Ha az elöl haladó jármű gyorsít, vagy átsorol a másik sávba, az Ön autója is fokozatosan felgyorsít, amíg el nem éri az előre beállított sebességet. Az adaptív sebességtartó automatikával a kívánt követési távolságot is beállíthatja (hosszú, közepes vagy rövid).</p>
<p>forrás: <a href="https://www.toyota.hu/world-of-toyota/safety/adaptive-cruise-control-how-it-works.json">toyota.hu / Adaptív sebességtartó automatika</a></p>
</blockquote>
<h3><a class="header" href="#bemutatóvideó-youtube" id="bemutatóvideó-youtube">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=own_VaRZ9M8"><img src="https://img.youtube.com/vi/own_VaRZ9M8/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3><a class="header" href="#implementálás" id="implementálás">Implementálás</a></h3>
<p>A kiválasztott célobjektum (autó előtt haladó NPC) sebességéhez igazítja a saját sebességet, vagy tartja a sofőr által kiválasztott sebességhatárt, ha nincs előtte célobjektum.</p>
<ul>
<li>ki- és bekapcsolható, reagál az állapotváltás, alapértelmezetten az aktuális sebesség, de min célsebesség 30 km/h</li>
<li>ha nincs saját sávban autó, a játékos autó tartja a kiválasztott célsebességet</li>
<li>ha saját sávban található autó:
<ul>
<li>felveszi a sebességét, ha lassabb</li>
<li>tartja a kiválasztott sebességet, ha gyorsabb</li>
</ul>
</li>
<li>fékezésre kikapcsol</li>
<li>AEB beavatkozásra kikapcsol</li>
<li>ha speed limitet talál a buszon (táblafelismerő), azt alkalmazza új célsebességként, amíg a sofőr felül nem írja</li>
</ul>
<p><img src="images/acc.png" alt="" /></p>
<h3><a class="header" href="#kezelőszervek" id="kezelőszervek">Kezelőszervek</a></h3>
<ul>
<li>bekapcsoló gomb</li>
<li>célsebesség kijelölése
<ul>
<li>léptetés 10 km/h-val</li>
<li>30 és 160 km/h között</li>
</ul>
</li>
<li>követési távolság definiálása másodpercben: 0.8, 1.0, 1.2, 1.4
<ul>
<li>sebességfüggő</li>
<li>a léptetés körbe jár, tehát 1.4 után 0.8 következik és a 0.8 után az 1.4</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#autonóm-vészfékező-rendszer-automatic-emergency-brake---aeb" id="autonóm-vészfékező-rendszer-automatic-emergency-brake---aeb">Autonóm vészfékező rendszer (Automatic Emergency Brake - AEB)</a></h2>
<blockquote>
<p>Az Autonóm Vészfékező Rendszer (AEB) lényege, hogy egy beépített technológia alkalmazásával (általában radar, kamera, vagy lézer segítségével) folyamatosan méri az elöl haladó jármű mögötti távolságot. Ha a rendszer úgy érzi, hogy a gépkocsik közötti távolság veszélyesen csökken, akkor jelzést ad a járművezetőnek, lehetőséget adva a beavatkozásra (pl. fékezésre). Amennyiben a járművezető reakciója elmarad, vagy annak mértékét a rendszer nem tartja elégségesnek, abban az esetben az AEB beavatkozik, s akár vészfékezés alkalmazásával igyekszik a balesetet elkerülni.</p>
<p>forrás: <a href="http://www.baleset-megelozes.eu/cikk.php?id=1032">baleset-megelozes.eu / Autonóm Vészfékező Rendszer (AEB)</a></p>
</blockquote>
<h3><a class="header" href="#bemutatóvideó-youtube-1" id="bemutatóvideó-youtube-1">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=VHR8AeZrlVc"><img src="https://img.youtube.com/vi/VHR8AeZrlVc/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3><a class="header" href="#implementálás-1" id="implementálás-1">Implementálás</a></h3>
<p>Nyilvánvalóan nem azt kell vizsgálni, hogy az autó ütközik-e az előtte levő objektummal hanem, hogy <em>ütközni fog-e vele</em>. A vészfékezés maximális lassulása 9 m/s^2 lehet. Ha az autó 36 m/s sebességgel halad akkor 4 másodperc kell a nullára fékezéshez (ha 50 km/h sebességgel halad, akkor 20). Az aktuális sebességből meghatározható, hogy mekkora a fékút, a maximális megengedett lassulás mellett. Az is kiszámolható, hogy ez mennyi időt vesz igénybe, így az is, hogy mikor kell elkezdeni a vészfékezést, hogy a gyalogost ne üssük el.</p>
<p>A radar szenzor elég messzire ellát, egy nem mozgó objektum (pl. fa) esetében egyszerű meghatározni, hogy lesz-e ütközés és el kell-e kezdeni vészfékezni. Mozgó objektum (gyalogos) esetében azt is figyelembe kell venni, hogy mire odaérünk még az úton lesz-e.</p>
<ul>
<li>elkerülhető ütközés esetén vizuális figyelmeztetés a sofőrnek</li>
<li>70 km/h felett figyelmeztetés, hogy az AEB nem tud minden helyzetet kezelni</li>
<li>ha a sofőr nem avatkozik közbe, automatikus fékezés (az utolsó pillanatban, ahol az ütközés még elkerülhető)</li>
<li>az automatikus fékezés mértéke a sebességgel arányos, de nem lehet 9 m/s^2-nél nagyobb</li>
<li>gyalogos, fa esetén megáll az autó</li>
<li>nincs nem releváns objektumokra való fékezés (fals pozitív) - pl. szembejövő autó</li>
</ul>
<p><img src="images/radar_aeb.png" alt="" /></p>
<h2><a class="header" href="#parkoló-asszisztens-parking-pilot---pp" id="parkoló-asszisztens-parking-pilot---pp">Parkoló asszisztens (Parking Pilot - PP)</a></h2>
<p>A rendszert az erre szolgáló vezérlővel aktiválni kell, majd az irányjelzővel kijelölni, hogy jobbra, vagy balra keressük a parkolóhelyet. Ezután ahogy az autó <em>vezetői irányítás mellett</em> végiggurul a parkoló mellett, a rendszer detektálja az üres parkolóhelyet. Ekkor hátramenetbe kapcsolva az PP vezetői beavatkozás nélkül beáll a szabad pozícióba.</p>
<h3><a class="header" href="#bemutatóvideók-youtube" id="bemutatóvideók-youtube">Bemutatóvideók (YouTube)</a></h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=HWMzP9HYNCQ"><img src="https://img.youtube.com/vi/HWMzP9HYNCQ/0.jpg" alt="Bemutatóvideó" /></a></li>
<li><a href="https://www.youtube.com/watch?v=rYPby2ALLnE"><img src="https://img.youtube.com/vi/rYPby2ALLnE/0.jpg" alt="Bemutatóvideó" /></a></li>
</ul>
<h3><a class="header" href="#implementálás-2" id="implementálás-2">Implementálás</a></h3>
<ul>
<li>a parkolás megkezdése külön inputhoz kötött</li>
<li>a kormány és gáz/fék vezérlésével beparkolás a talált helyre
<ul>
<li>a tolatási manőver lehet egy előre definiált szekvencia, amelyet a parkolóhely (abszolút) pozíciójával lehet paraméterezni</li>
</ul>
</li>
<li>ha a PP aktív és a váltó hátramenetben van (és van detektált parkolóhely), akkor parkolási szekvencia végrehajtása</li>
<li>a párhuzamos parkolás akkor sikeres, ha ütközés nélkül megtörténik</li>
<li>a sofőr beavatkozására (fék, gáz, kormány) kikapcsolás (megszűnik az automata vezérlés)</li>
</ul>
<ol>
<li>parkolóhely keresése
<ul>
<li><img src="images/find_parking_place_horizontal.png" alt="" /></li>
<li>Az üres hely detektálása lényegébe egy állapotátmenet az első és a hátsó ultrahang szenzor „van-e akadály” visszajelzésében. Amíg egy kocsisor mellett halad az autó mindkét szenzor „van akadály” jelzéssel tér vissza (ez valójában nem <code>boolean</code> állapot, egy objektum listát ad vissza), az üres hely kezdetén a az első „nincs akadály” állapotba megy át (a lista üres), majd ahogy az autó halad tovább a hátsó szenzor is „nincs akadály” állapotba kerül.</li>
<li>A szabad terület végén ugyanez fordítva játszódik le.</li>
<li>Azonban a parkoló autó objektumot adja vissza a szenzor,a melynek ismert a kiterjedése és a referencia pontja, így a játékszoftverben pontosan „látszik” a foglalt terület. Ahogy az egocar elhalad a parkoló autók mellett mindkét autó által lefoglalt terület pontosan ismert így kiszámítható a közöttük meglevő szabad terület.</li>
</ul>
</li>
<li>Parkolóhely azonosítva
<ul>
<li><img src="images/parking_place_found_horizontal.png" alt="" /></li>
<li>Miután sikerült meghatározni a szabad parkolóhely méretét, ezt valamiylen formában le kell írni. Célszerűen az egocar referenciapontjáthoz viszonyítva, hogy milyen távol vagyunk tőle, valamint a méretét/hosszát. Lehet egy téglalappal is reprezentálni ahogy az ábrán is látszik.</li>
</ul>
</li>
<li>Automatikus parkolás
<ul>
<li><img src="images/parking_horizontal.png" alt="" /></li>
<li>A parkolási manőver tökéletes megoldása, hogy a <em>Parking Pilot</em> az autó kezelőszerveire hat. Eltekeri a kormányt, gázt ad, fékez, nem csak úgy módosítgatja az autó koordinátáit és elforgatását. (Mindez precízen szabályozható hajtáslánc és kormánymechanika implementációt igényel.)</li>
</ul>
</li>
</ol>
<hr />
<p>Parkolás manőver leírása nagy vonalakban <a href="https://www.dmv.ca.gov/portal/dmv/detail/pubs/hdbk/parking">forrás</a>:</p>
<ol>
<li>Bring your car to a stop alongside the car at the front of the space.
<ul>
<li><img src="https://www.dmv.ca.gov/imageserver/dmv/images/dlhdbk/perfect1.jpg" alt="" /></li>
</ul>
</li>
<li>Reverse into the space with an S motion.
<ul>
<li><img src="https://www.dmv.ca.gov/imageserver/dmv/images/dlhdbk/perfect2.jpg" alt="" /></li>
</ul>
</li>
<li>Once the car is parallel with the curb, pull forward to center your car within the space.
<ul>
<li><img src="https://www.dmv.ca.gov/imageserver/dmv/images/dlhdbk/perfect3.jpg" alt="" /></li>
</ul>
</li>
</ol>
<h3><a class="header" href="#kezelőszervek-1" id="kezelőszervek-1">Kezelőszervek</a></h3>
<ul>
<li>aktiválás billentyűzettel</li>
<li>az irányjelzővel jelölhető ki keresési oldal</li>
</ul>
<h2><a class="header" href="#sávtartó-automatika-lane-keeping-assistant---lka" id="sávtartó-automatika-lane-keeping-assistant---lka">Sávtartó automatika (Lane Keeping Assistant - LKA)</a></h2>
<h3><a class="header" href="#bemutatóvideó-youtube-2" id="bemutatóvideó-youtube-2">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=GdtVe1Pnayg"><img src="https://img.youtube.com/vi/GdtVe1Pnayg/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3><a class="header" href="#implementálás-3" id="implementálás-3">Implementálás</a></h3>
<p>Két jellemző megvalósítása van. Az egyik a sáv széleihez viszonyítva korrigál: ha az autó elérné a sáv szélét, akkor ellenkormányoz. A másik megoldás kiszámolja a sáv közepét és azon tartja az autót.</p>
<ul>
<li>45 foknál enyhébb kanyarodású úton a kocsi a sáv szemmel látható közepén marad</li>
<li>ha el kell engednie a kontrollt (az automatika számára kezelhetetlen forgalmi szituáció következik, pl. éles kanyar, kereszteződés), vizuális figyelmeztetést ad
Ha újra elérhető a funkció (pl. elhagytuk a kanyart) vizuális indikáció (a műszerfalon)
Be- és kikapcsolható</li>
</ul>
<h4><a class="header" href="#1-sáv-széleinek-használata" id="1-sáv-széleinek-használata">1. Sáv széleinek használata</a></h4>
<p><img src="images/lka_a.png" alt="" /></p>
<h4><a class="header" href="#2-sávközép-használata" id="2-sávközép-használata">2. Sávközép használata</a></h4>
<p><img src="images/lka_b.png" alt="" /></p>
<p>Sávon belüli mozgás: a LKA működése egy enyhe sávon belüli cikázást eredményez.</p>
<p><img src="images/lka_wave.png" alt="" /></p>
<h3><a class="header" href="#kezelőszervek-2" id="kezelőszervek-2">Kezelőszervek</a></h3>
<ul>
<li>aktiválás a műszerfalról (vagy billentyűzettel)</li>
</ul>
<h2><a class="header" href="#táblafelismerő-traffic-sign-recognition---tsr" id="táblafelismerő-traffic-sign-recognition---tsr">Táblafelismerő (Traffic Sign Recognition - TSR)</a></h2>
<p>A kamera látóterébe eső és az autó számára releváns (ellentétes irányba közlekedők számára szólóakat nem) közlekedési táblákat fel kell ismerni és a legutolsó relevánsat megjeleníteni a műszerfalon. Ha ez sebességkorlátozás, akkor azt a buszra kiírni (az ACC használja).</p>
<h3><a class="header" href="#bemutatóvideó-youtube-3" id="bemutatóvideó-youtube-3">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=RFuUvqxbuSc"><img src="https://img.youtube.com/vi/RFuUvqxbuSc/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3><a class="header" href="#implementálás-4" id="implementálás-4">Implementálás</a></h3>
<ul>
<li>a táblát addig kell megjeleníteni, amíg újabb nem talál a rendszer</li>
<li>a sebesség limit mindaddig érvényes, míg feloldásra vagy felülbírálásra nem kerül</li>
<li>nem releváns táblák nem kerülhetnek azonosításra
<ul>
<li>mindenek előtt az út bal oldalán levők</li>
</ul>
</li>
<li>a kamera látótere elég nagy, a kanyaroknál kialakuló helyzetet is kezelni kell</li>
</ul>
<p><img src="images/tsr.png" alt="" /></p>
<h2><a class="header" href="#tolatóradar" id="tolatóradar">Tolatóradar</a></h2>
<p>A hátsó ultrahang szenzorokat használja akadály detektálásra. Kiszámolja az akadály távolságát és annak megfelelően figyelmeztető jelzést ad a vezetőnek, megkönnyítve a manuális parkolást, tolatást.</p>
<h3><a class="header" href="#bemutatóvideó-youtube-4" id="bemutatóvideó-youtube-4">Bemutatóvideó (YouTube)</a></h3>
<p><a href="https://www.youtube.com/watch?v=qZkCoDChS4A"><img src="https://img.youtube.com/vi/qZkCoDChS4A/0.jpg" alt="Bemutatóvideó" /></a></p>
<h3><a class="header" href="#implementálás-5" id="implementálás-5">Implementálás</a></h3>
<ul>
<li>csak hátramenetben aktív</li>
<li>figyelmeztetés megjelenítése a műszerfalon</li>
<li>távolság megjelenítése a műszerfalon</li>
<li>a buszon keresztül történik a modulok (tolatóradar és műszerfal) kommunikáció</li>
<li>a kijelzés 3 fokozatban történik
<ul>
<li>nincs akadály</li>
<li>közel van akadály (0.8m-en belül)</li>
<li>nagyon közel van akadály (0.4m-en belül)</li>
</ul>
</li>
</ul>
<p><img src="images/reverse_radar_system_horizontal.png" alt="" /></p>
<h1><a class="header" href="#fun-kategória" id="fun-kategória">„Fun” kategória</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=Xbjdmw8D9-Y">Hyundai - The Empty Car Convoy</a>
<ul>
<li>LKA, ACC and AEB marketing</li>
</ul>
</li>
<li><a href="https://youtu.be/tazFfEP_NcY">Nissan Parking Pilot inspirálta helyére ”parkoló” papucsa</a></li>
</ul>
<h1><a class="header" href="#referencia-architektúra" id="referencia-architektúra">Referencia architektúra</a></h1>
<p>A repó található kezdeti kódot (skeleton) egységes alapot képez a félév során megvalósítandó szoftver számára, azonban nem kíván tökéletes és teljes megoldást biztosítani a feladat egyetlen elemére sem, mindösszesen példaként szolgál a következőkre:</p>
<ul>
<li>projekt struktúra</li>
<li>grafikus felület létrehozása
<ul>
<li>Avalonia keretrendszerrel</li>
</ul>
</li>
<li>világmodell benépesítése</li>
<li>vezérelt autó példányosítása és kiválasztása</li>
<li>képfájl betöltése projektkönyvtárból</li>
<li>világobjektumok rajzolása MVVM rendszerben</li>
<li>vezérelt autó állapotának megjelenítése a műszerfalon</li>
<li>ütemező használata</li>
<li>billentyű lenyomás és felengedés esemény kezelése</li>
<li>szenzor objektum létrehozása</li>
<li>adatcsomag küldése és fogadása a <em>Virtual Function Bus</em>-on keresztül</li>
</ul>
<p>A fejezet további felépítse:</p>
<!-- toc -->
<h2><a class="header" href="#virtual-function-bus" id="virtual-function-bus">Virtual Function Bus</a></h2>
<p>A VirtualFunctionBus (VFB) egy kommunikációs megoldás az AutomatedCar komponensei (SystemComponent) számára. A komponensek feliratkoznak a buszra és <strong>a feliratkozás sorrendjében</strong> ciklikusan meghívásra kerül a <code>Process()</code> metódusok.</p>
<p>Ebből következik, hogy a feliratkozást az ábrán látható sorrendben kell megtenni, mivel az adatáramlásnak ilyen irányultsága van. Az ábra a kód kezdeti állapotát szemlélteti, a munka során további modulok (szenzorok, vezetés támogató rendszerek) is csatlakoznak majd. Valamint a hajtáslánc és a kormányzás modult nem kötelező ennyire élesen szétválasztani.</p>
<p><img src="plantuml/dummy_sensor_vfb.svg" alt="" /></p>
<p>Minden adatközlő modulnak létre kell hoznia egy-egy csomag (packet) típust (és vele párhuzamosan egy az olvasást biztosító interfészt), amely tartalmazza azokat az információkat amelyeket továbbítania kell. Például az input modul a pedál és kormány állásokat. A hajtáslánc a következő, kiolvassa a pedál és váltó állást, számol vele, majd visszaírja a <em>saját</em> csomagjába motor fordulatszámát és az autó sebességét, stb. Ezekre legközelebb a kormányzás modulnak lesz szüksége, az kiolvassa ugyanúgy mint az input modul kormányállás értékét, számol vele, majd visszaírja a autó adott iterációra vonatkozó elmozdulását.</p>
<h3><a class="header" href="#használata-általánosan" id="használata-általánosan">Használata általánosan</a></h3>
<ol>
<li>Create a new package (e.g. SteeringAnglePacket)</li>
<li>Create a new interface for it (e.g. IReadonlySteeringAnglePacket)</li>
<li>Add reference to the owner component (e.g. SteeringSystem)</li>
<li>Add the interface reference to the VirtualFunctionBus</li>
<li>In the loop method of the writing componenet set the payload value of the packet</li>
<li>In the loop method of the reading compontent read the payload of the packet</li>
</ol>
<h3><a class="header" href="#konkrét-példán-keresztül-dummysensor" id="konkrét-példán-keresztül-dummysensor">Konkrét példán keresztül: DummySensor</a></h3>
<p>A <em>DummySensor</em> egy rendkívül primitív „szenzor”: egyetlen feladata, hogy kiszámolja az egocar ás a <em>Circle</em> objektum közötti távolságot. Pontosabban az egocar és a kör referenciapont X, Y koordinátáinak különbségét. Azonban ez is teljes mértékben képes bemutatni a szenzorok működését és a buszon keresztüli adatcserét.</p>
<p>A példa szempontjából releváns komponensek viszonyát alábbi ábra szemlélteti.</p>
<p><img src="plantuml/dummy_sensor_component.svg" alt="" /></p>
<!--
```plantuml
@startuml
component [World] as world {

  component [AutomatedCar] as egocar {
    component [DummySensor] as ds
    component [VirtualFunctionBus] as vfb

    interface register as rc
  }

  component [Circle] {
  }
  
  ds -left-( rc
  vfb -right- rc
 
}

header
DummySensor component diagram
endheader

@enduml
```
-->
<p>A <em>World</em> singleton osztály tartalmaz minden <em>WorldObject</em>-et és tartalmaz referenciát a vezérelt autóra, amely közvetetten szintén <em>WorldObject</em>, csakúgy mint a <em>Circle</em>. Az <em>AutomatedCar</em> tartalmazza a <em>VirtualFunctionBus</em>-t, mivel ez az autó komponenseinek kommunikációs csatornáját valósítja meg. Szintén az <em>AutomatedCar</em> tartalmazza a szenzorokat, jelen esetben a <em>DummySensor</em>-t.</p>
<p>Ahhoz, hogy a szenzorok (vagy egyéb komponensek mint a hajtáslánc például) adatot cserélhessenek fel kell iratkozniuk a VFB-ra. Miután a feliratkozás megtörtént, a VFB minden ciklusában meghívja a <code>Porcess()</code> metódusát. A <em>DummySensor</em> esetében ez a metódus elkéri a világtól a <em>kör</em> objektumot, kiszámolja a vezérelt autó és a kör távolságát, majd ezt a távolságot eltárolja a <em>DummyPacket</em> objektumban (amely egy IReadOnlyDummyPacket típuson keresztül a VFB-ban van tárolva).</p>
<!-- A szenzor része az *AutomatedCar*-nak, közvetlenül hozzáférhet a világhoz (*World*) mivel az singleton. Lekéri a világobjektumok közül a kört (*Circle*), majd kiszámolja a koordináták különbségét a `process()` metódusban és az eredményt eltárolja az `dummyPacket` változóban. -->
<p>A <code>dummyPacket</code> referenciája eltárolásra került a <em>VirtualFunctionBus</em>ban, amely referenciáját a a szenzor konstruktorának biztosítani kell. Ehhez előzetesen létre kell hozni egy <code>IReadOnlyDummyPacket</code> típusú változót a VFB-ban.</p>
<p>Miután a <code>DummyPacket</code> megvalósítja az <code>IReadOnlyDummyPacket</code> interfészt, a VFB-ban az utóbbi típus tárolására szolgáló változó kerül deklarálásra. Ezzel biztosítható, hogy az adott értéket csak a csomag tulajdonosa (jelen esetben a <em>DummySensor</em>) tudja majd írni, de minden más komponens olvashatja a VFB-on keresztül.</p>
<!--
```plantuml
@startuml
DummySensor -> VirtualFunctionBus: registerComponent
loop
    VirtualFunctionBus -> DummySensor: Process
    activate DummySensor
    DummySensor -> World: Get Circle

    DummySensor -> DummySensor: Calculate distance from Circle
    DummySensor -> DummyPacket: Store distance
    deactivate DummySensor
end

header
DummySensor sequence diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_sequence.svg" alt="" /></p>
<p>Ez lejátszódik minden iterációban, így a kör és a vezérelt autó mindenkori helyzete szerinti távolságot fogja tartalmazni a <em>DummyPacket</em>.</p>
<!-- Az alábbi ábra a *DummySensor* szenpontjából fontos osztályok kapcsolatát mutatja. -->
<h3><a class="header" href="#osztálydiagramok" id="osztálydiagramok">Osztálydiagramok</a></h3>
<!--
```plantuml
@startuml
abstract class GameBase {
    + int TicksPerSecond
    + long CurrentTick
    - DispatcherTimer _timer

    void DoTick()
    # {abstract} void Tick()
    + void Start()
    + void Stop()
}

class VirtualFunctionBus {
    - SystemComponent[] components
    - IReadOnlyDummyPacket DummyPacket
    + int getIReadOnlyDummyPacket()
    + void setIReadOnlyDummyPacket()
    + void registerComponent(SystemComponent component)
}

abstract class SystemComponent {
    # VirtualFunctionBus virtualFunctionBus
    # SystemComponent(VirtualFunctionBus virtualFunctionBus)
    + {abstract} void Process()
}

class DummySensor {
   - DummyPacket dummyPacket
}

class DummyPacket {
    - int distanceX
    - int distanceY
    + void setDistanceX()
    + int getDistanceX()
    + void setDistanceY()
    + int getDistanceY()
}

interface IReadOnlyDummyPacket {
    + int getDistanceX()
    + int getDistanceY()
}

DummySensor <|-- SystemComponent
DummySensor *-- DummyPacket
DummyPacket <-- IReadOnlyDummyPacket

VirtualFunctionBus <|-- GameBase
VirtualFunctionBus *-- "many" SystemComponent
VirtualFunctionBus *-- "1" IReadOnlyDummyPacket

header
DummySensor class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_class.svg" alt="" /></p>
<!--
```plantuml
@startuml
    interface ReactiveObject {
    }
    note right: This is required to update the View in the MVVM model.\nRaiseAndSetIfChanged() method must be used in the setters.

    class World << (S, #FF7700) Singleton >> {
        - int width
        - int height
        - WorldObject[] worldObjects
        - AutomatedCar controlledCar
        + int getWidth()
        + void setWidth()
        + int getHeight()
        + void setHeight()
        + void addObject()
        + AutomatedCar getControlledCar()
        + void setControlledCar()
    }

    abstract class WorldObject {
        - int x
        - int y
        - int zIndex
        - string filename
        + int getX()
        + void setX()
        + int getY()
        + void setY()
        + string getFilename()
        + void setFilename()
    }

    class Car {
        - int speed
        + int getSpeed()
        + void setSpeed()
    }

    class AutomatedCar {
        - VirtualFunctionBus virtualFunctionBus
        - DummySensor dummySensor
        + VirtualFunctionBus getVirtualFunctionBus()
        + void Start()
        + void Stop()
    }

    AutomatedCar <|-- Car
    Car <|-- WorldObject
    WorldObject <|-- ReactiveObject
    World *-- "many" WorldObject

header
AutomatedCar class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/automatedcar_class.svg" alt="" /></p>
<h2><a class="header" href="#megjelenítés" id="megjelenítés">Megjelenítés</a></h2>
<p>Az elkészítendő szoftver felhasználói felületének az alábbi vázlat felépítését kell követnie.</p>
<p><img src="images/gui_plan.png" alt="gui plan" /></p>
<p>A programablak bal oldalán a virtuális világ egy szeletét látjuk ezért felel a vizualizációs modul. A megjelenítés középpontja az mindenkor vezérelt autó (egocar). A világ minden eleméhez tartozik egy képfájl, ezen elemek megfelelő transzformációk (forgatás, skálázás) végrehajtása után kirajzolásra kerülne a CourseDisplayre.</p>
<p>Továbbá erre a részre kerülnek kirajzolásra a debuggoláshoz és teszteléshez használandó segédobjektumok opionálisan bekapcsolható megjelenítése. Ide tartozik a szenzorok látómezeje, a világobjektumok „poligon váza”, valamint utóbbiak eseményre történő kiemelésének lehetősége.</p>
<p>A jobb oldalon a műszerfal található. A műszerfalon nincsenek vezérlőelemek, csak megjelenítés. Az összes kapcsoló a billentyűzettel állítható, a grafikus elemeknek nem kell pl. egérrel kapcsolhatónak lenniük.</p>
<p>A fordulatszám és a sebesség legyen egy analóg órával reprezentálva; a kormány elforgazás, a gáz- és fékpedál állása progressbar-okkal szemléltethető. Az irányjelző visszajelzője és a vezetéstámogató funkciók visszajelzői lámpaszerűek, a sebességváltó állása, és a debug értékek pl. kocsi pozíciója (x, y koordináta) lehet szöveges.
A buszon közölt „utoljára látott tábla” képét ki kell tudni rajzolni (a képek rendelkezésre állnak). Legyen elkülönítve a nincs tábla eset is.</p>
<p>Az <a href="http://avaloniaui.net/"><em>Avalonia</em> keretrendszer</a> által is használt <a href="http://avaloniaui.net/docs/quickstart/mvvm">MVVM modell</a>ben az objektumokhoz tartozik egy definiált a megjelenítés.</p>
<p><img src="http://avaloniaui.net/docs/quickstart/images/mvvm.png" alt="" /></p>
<p>Jelen esetben például a műszerfal egy <em>AutomatedCar</em> objektum megjelenítése. Egészen pontosana <em>World</em>-ben tárolt <code>controlledCar</code> objektumé. A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name=&quot;Dashboard&quot; Content=&quot;{Binding World.ControlledCar, Mode=OneWay}&quot; &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3><a class="header" href="#coursedisplay" id="coursedisplay">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel befolyásolni lehet a rajzolást (transzformálás).</p>
<pre><code class="language-xml">&lt;ItemsControl Name=&quot;CourseDisplay&quot;
    DataContext=&quot;{Binding World, Mode=OneWay}&quot;
    Items=&quot;{Binding WorldObjects, Mode=OneWay}&quot;
    Width=&quot;{Binding Width, Mode=OneWay}&quot;
    Height=&quot;{Binding Height, Mode=OneWay}&quot;
    HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot;
    &gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas/&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.DataTemplates&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:WorldObject}&quot;&gt;
            &lt;Image Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot;
                Source=&quot;{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}&quot;/&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.DataTemplates&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl.DataTemplates&gt;
    &lt;DataTemplate DataType=&quot;{x:Type models:Circle}&quot;&gt;
        &lt;Canvas&gt;
            &lt;Ellipse Fill=&quot;black&quot; Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot; ZIndex=&quot;10&quot;/&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
    &lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
        &lt;Canvas&gt;
            &lt;Image Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot;
                Source=&quot;{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}&quot;/&gt;
            &lt;Polyline Stroke=&quot;{Binding Brush, Mode=OneWay}&quot; Points=&quot;{Binding Geometry.Points, Mode=OneWay}&quot; /&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
&lt;/ItemsControl.DataTemplates&gt;
</code></pre>
<h4><a class="header" href="#pozicionálás" id="pozicionálás">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példák nem rendelkeznek az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az alábbi példa beszínezi zöldre a <em>CourseDisplay</em>-t, valamint a <em>WorldObject</em>-ek <em>Left</em> és <em>Top</em> értékeit beállítja a <em>WorldObject</em> X és Y értének megfelelően.</p>
<pre><code class="language-xml">&lt;UserControl.Styles&gt;
    &lt;Style Selector=&quot;ItemsControl#CourseDisplay&quot;&gt;
        &lt;Setter Property=&quot;Background&quot; Value=&quot;#97D1A2&quot;/&gt;
    &lt;/Style&gt;
    &lt;Style Selector=&quot;ItemsControl#CourseDisplay &gt; ContentPresenter&quot;&gt;
        &lt;Setter Property=&quot;Canvas.Left&quot; Value=&quot;{Binding X, Mode=OneWay}&quot;/&gt;
        &lt;Setter Property=&quot;Canvas.Top&quot; Value=&quot;{Binding Y, Mode=OneWay}&quot;/&gt;
        &lt;Setter Property=&quot;ZIndex&quot; Value=&quot;{Binding ZIndex, Mode=OneWay}&quot;/&gt;
    &lt;/Style&gt;
&lt;/UserControl.Styles&gt;
</code></pre>
<p>Az utóbbi verziót használva az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="context-cards.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="d3.5.16.0.js"></script>
        
        <script type="text/javascript" src="markmap-lib.transform.min.js"></script>
        
        <script type="text/javascript" src="markmap-lib.view.min.js"></script>
        
        <script type="text/javascript" src="markmap-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
