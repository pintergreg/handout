<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Referencia architektúra - Jegyzet</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Szoftverfejlesztés multinacionális vállalatoknál">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="description.html"><strong aria-hidden="true">1.</strong> Tárgyleírás</a></li><li class="chapter-item expanded "><a href="schedule.html"><strong aria-hidden="true">2.</strong> Ütemezés</a></li><li class="chapter-item expanded "><a href="literature.html"><strong aria-hidden="true">3.</strong> Felkészülést segítő anyagok</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lectures/software_architecture.html"><strong aria-hidden="true">3.1.</strong> Software Architecture</a></li><li class="chapter-item "><a href="lectures/daily_work.html"><strong aria-hidden="true">3.2.</strong> Daily Work, Clean Code, Version Control</a></li><li class="chapter-item "><a href="lectures/agile_scrum_kanban.html"><strong aria-hidden="true">3.3.</strong> Agile, SCRUM, Kanban</a></li><li class="chapter-item "><a href="lectures/tdd.html"><strong aria-hidden="true">3.4.</strong> TDD, Unit Testing</a></li><li class="chapter-item "><a href="lectures/legacy_code.html"><strong aria-hidden="true">3.5.</strong> Legacy Code, SOLID</a></li><li class="chapter-item "><a href="lectures/review.html"><strong aria-hidden="true">3.6.</strong> Review</a></li><li class="chapter-item "><a href="lectures/ci.html"><strong aria-hidden="true">3.7.</strong> Continuous Integration</a></li><li class="chapter-item "><a href="mindmap.html"><strong aria-hidden="true">3.8.</strong> MindMap</a></li></ol></li><li class="chapter-item expanded "><a href="software.html"><strong aria-hidden="true">4.</strong> A feladat</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints/sprints.html"><strong aria-hidden="true">4.1.</strong> Sprintek</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints/sprint_1.html"><strong aria-hidden="true">4.1.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprints/sprint_2.html"><strong aria-hidden="true">4.1.2.</strong> Sprint 2</a></li></ol></li><li class="chapter-item "><a href="sprints_old/sprints.html"><strong aria-hidden="true">4.2.</strong> Sprintek [régi]</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sprints_old/sprint_1.html"><strong aria-hidden="true">4.2.1.</strong> Sprint 1</a></li><li class="chapter-item "><a href="sprints_old/sprint_2.html"><strong aria-hidden="true">4.2.2.</strong> Sprint 2</a></li><li class="chapter-item "><a href="sprints_old/sprint_3.html"><strong aria-hidden="true">4.2.3.</strong> Sprint 3</a></li></ol></li><li class="chapter-item "><a href="demo.html"><strong aria-hidden="true">4.3.</strong> Demók</a></li><li class="chapter-item "><a href="sprints/convoy.html"><strong aria-hidden="true">4.4.</strong> Acceptance test</a></li></ol></li><li class="chapter-item expanded "><a href="working_environment.html"><strong aria-hidden="true">5.</strong> Munkakörnyezet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">5.1.</strong> Git</a></li><li class="chapter-item "><a href="github.html"><strong aria-hidden="true">5.2.</strong> GitHub</a></li><li class="chapter-item "><a href="developing_tools.html"><strong aria-hidden="true">5.3.</strong> Fejlesztői eszközök</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="vs_code.html"><strong aria-hidden="true">5.3.1.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="intellij_rider.html"><strong aria-hidden="true">5.3.2.</strong> IntelliJ Rider</a></li><li class="chapter-item "><a href="intellij_idea.html"><strong aria-hidden="true">5.3.3.</strong> IntelliJ IDEA (Java)</a></li><li class="chapter-item "><a href="code_formatting.html"><strong aria-hidden="true">5.3.4.</strong> Kódformázás</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="csharp_style_guide.html"><strong aria-hidden="true">5.3.4.1.</strong> C#</a></li><li class="chapter-item "><a href="java_style_guide.html"><strong aria-hidden="true">5.3.4.2.</strong> Java</a></li></ol></li></ol></li><li class="chapter-item "><a href="workflow.html"><strong aria-hidden="true">5.4.</strong> Munkafolyamat</a></li></ol></li><li class="chapter-item expanded "><a href="implementation.html"><strong aria-hidden="true">6.</strong> Implementáció</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="virtual_world.html"><strong aria-hidden="true">6.1.</strong> Virtuális világ</a></li><li class="chapter-item "><a href="physics.html"><strong aria-hidden="true">6.2.</strong> Fizika</a></li><li class="chapter-item "><a href="sensors.html"><strong aria-hidden="true">6.3.</strong> Szenzorok</a></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">6.4.</strong> Vezetéstámogató funkciók</a></li><li class="chapter-item expanded "><a href="reference_architecture.html" class="active"><strong aria-hidden="true">6.5.</strong> Referencia architektúra</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jegyzet</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="referencia-architektúra"><a class="header" href="#referencia-architektúra">Referencia architektúra</a></h1>
<p>A repó található kezdeti kódot (skeleton) egységes alapot képez a félév során megvalósítandó szoftver számára, azonban nem kíván tökéletes és teljes megoldást biztosítani a feladat egyetlen elemére sem, mindösszesen példaként szolgál a következőkre:</p>
<ul>
<li>projekt struktúra</li>
<li>grafikus felület létrehozása
<ul>
<li>WPF keretrendszerrel</li>
<li>Avalonia keretrendszerrel</li>
</ul>
</li>
<li>világmodell benépesítése</li>
<li>vezérelt autó példányosítása és kiválasztása</li>
<li>képfájl betöltése projektkönyvtárból</li>
<li>világobjektumok rajzolása MVVM rendszerben</li>
<li>vezérelt autó állapotának megjelenítése a műszerfalon</li>
<li>ütemező használata</li>
<li>billentyű lenyomás és felengedés esemény kezelése</li>
<li>szenzor objektum létrehozása</li>
<li>adatcsomag küldése és fogadása a <em>Virtual Function Bus</em>-on keresztül</li>
</ul>
<!-- A fejezet további felépítse: -->
<!-- toc -->
<h2 id="Átfogó-kép"><a class="header" href="#Átfogó-kép">Átfogó kép</a></h2>
<p>A teljes szoftver moduljai <a href="sprints.html">12 user story</a>-ra vannak bontva. Az egyes modulok a teljes szoftver egy-egy komponensét valósítják meg. A legtöbb ilyen komponens a vezérelt autón belül kap majd helyet. Azonban vannak olyan komponensek (irányítás és megjelenítés), amelyek  nem csak az autón belül, de azon kívül, a keretszoftverben működnek.</p>
<p><img src="images/full_software.png" alt="" /></p>
<p>A billentyűzet események kezelése értelemszerűen a szoftverban történik, amelyet aztán a szimulált autó kezelőszerveire (gáz- és fékpedál, kormány) kell leképezni.
A megjelenítésnek pedig értelemszerűen a teljes világot, de legalábbis az autó egy környezetét kell, hogy kirajzolnia.</p>
<h2 id="virtual-function-bus"><a class="header" href="#virtual-function-bus">Virtual Function Bus</a></h2>
<p>A VirtualFunctionBus (VFB) egy kommunikációs megoldás az AutomatedCar komponensei (SystemComponent) számára. A komponensek feliratkoznak a buszra és <strong>a feliratkozás sorrendjében</strong> ciklikusan meghívásra kerül a <code>Process()</code> metódusok.</p>
<p>Ebből következik, hogy a feliratkozást az ábrán látható sorrendben kell megtenni, mivel az adatáramlásnak ilyen irányultsága van. Az ábra a kód kezdeti állapotát szemlélteti, a munka során további modulok (szenzorok, vezetés támogató rendszerek) is csatlakoznak majd. Valamint a hajtáslánc és a kormányzás modult nem kötelező ennyire élesen szétválasztani.</p>
<p><img src="plantuml/dummy_sensor_vfb.svg" alt="" /></p>
<p>Minden adatközlő modulnak létre kell hoznia egy-egy csomag (packet) típust (és vele párhuzamosan egy az olvasást biztosító interfészt), amely tartalmazza azokat az információkat amelyeket továbbítania kell. Például az input modul a pedál és kormány állásokat. A hajtáslánc a következő, kiolvassa a pedál és váltó állást, számol vele, majd visszaírja a <em>saját</em> csomagjába motor fordulatszámát és az autó sebességét, stb. Ezekre legközelebb a kormányzás modulnak lesz szüksége, az kiolvassa ugyanúgy mint az input modul kormányállás értékét, számol vele, majd visszaírja a autó adott iterációra vonatkozó elmozdulását.</p>
<h3 id="használata-általánosan"><a class="header" href="#használata-általánosan">Használata általánosan</a></h3>
<ol>
<li>Create a new package (e.g. SteeringAnglePacket)</li>
<li>Create a new interface for it (e.g. IReadonlySteeringAnglePacket)</li>
<li>Add reference to the owner component (e.g. SteeringSystem)</li>
<li>Add the interface reference to the VirtualFunctionBus</li>
<li>In the loop method of the writing componenet set the payload value of the packet</li>
<li>In the loop method of the reading compontent read the payload of the packet</li>
</ol>
<h3 id="konkrét-példán-keresztül-dummysensor"><a class="header" href="#konkrét-példán-keresztül-dummysensor">Konkrét példán keresztül: DummySensor</a></h3>
<p>A <em>DummySensor</em> egy rendkívül primitív „szenzor”: egyetlen feladata, hogy kiszámolja az egocar ás a <em>Circle</em> objektum közötti távolságot. Pontosabban az egocar és a kör referenciapont X, Y koordinátáinak különbségét. Azonban ez is teljes mértékben képes bemutatni a szenzorok működését és a buszon keresztüli adatcserét.</p>
<p>A példa szempontjából releváns komponensek viszonyát alábbi ábra szemlélteti.</p>
<p><img src="plantuml/dummy_sensor_component.svg" alt="" /></p>
<!--
```plantuml
@startuml
component [World] as world {

  component [AutomatedCar] as egocar {
    component [DummySensor] as ds
    component [VirtualFunctionBus] as vfb

    interface register as rc
  }

  component [Circle] {
  }
  
  ds -left-( rc
  vfb -right- rc
 
}

header
DummySensor component diagram
endheader

@enduml
```
-->
<p>A <em>World</em> singleton osztály tartalmaz minden <em>WorldObject</em>-et és tartalmaz referenciát a vezérelt autóra, amely közvetetten szintén <em>WorldObject</em>, csakúgy mint a <em>Circle</em>. Az <em>AutomatedCar</em> tartalmazza a <em>VirtualFunctionBus</em>-t, mivel ez az autó komponenseinek kommunikációs csatornáját valósítja meg. Szintén az <em>AutomatedCar</em> tartalmazza a szenzorokat, jelen esetben a <em>DummySensor</em>-t.</p>
<p>Ahhoz, hogy a szenzorok (vagy egyéb komponensek mint a hajtáslánc például) adatot cserélhessenek fel kell iratkozniuk a VFB-ra. Miután a feliratkozás megtörtént, a VFB minden ciklusában meghívja a <code>Porcess()</code> metódusát. A <em>DummySensor</em> esetében ez a metódus elkéri a világtól a <em>kör</em> objektumot, kiszámolja a vezérelt autó és a kör távolságát, majd ezt a távolságot eltárolja a <em>DummyPacket</em> objektumban (amely egy IReadOnlyDummyPacket típuson keresztül a VFB-ban van tárolva).</p>
<!-- A szenzor része az *AutomatedCar*-nak, közvetlenül hozzáférhet a világhoz (*World*) mivel az singleton. Lekéri a világobjektumok közül a kört (*Circle*), majd kiszámolja a koordináták különbségét a `process()` metódusban és az eredményt eltárolja az `dummyPacket` változóban. -->
<p>A <code>dummyPacket</code> referenciája eltárolásra került a <em>VirtualFunctionBus</em>ban, amely referenciáját a a szenzor konstruktorának biztosítani kell. Ehhez előzetesen létre kell hozni egy <code>IReadOnlyDummyPacket</code> típusú változót a VFB-ban.</p>
<p>Miután a <code>DummyPacket</code> megvalósítja az <code>IReadOnlyDummyPacket</code> interfészt, a VFB-ban az utóbbi típus tárolására szolgáló változó kerül deklarálásra. Ezzel biztosítható, hogy az adott értéket csak a csomag tulajdonosa (jelen esetben a <em>DummySensor</em>) tudja majd írni, de minden más komponens olvashatja a VFB-on keresztül.</p>
<!--
```plantuml
@startuml
DummySensor -> VirtualFunctionBus: registerComponent
loop
    VirtualFunctionBus -> DummySensor: Process
    activate DummySensor
    DummySensor -> World: Get Circle

    DummySensor -> DummySensor: Calculate distance from Circle
    DummySensor -> DummyPacket: Store distance
    deactivate DummySensor
end

header
DummySensor sequence diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_sequence.svg" alt="" /></p>
<p>Ez lejátszódik minden iterációban, így a kör és a vezérelt autó mindenkori helyzete szerinti távolságot fogja tartalmazni a <em>DummyPacket</em>.</p>
<!-- Az alábbi ábra a *DummySensor* szenpontjából fontos osztályok kapcsolatát mutatja. -->
<h3 id="osztálydiagramok"><a class="header" href="#osztálydiagramok">Osztálydiagramok</a></h3>
<!--
```plantuml
@startuml
abstract class GameBase {
    + int TicksPerSecond
    + long CurrentTick
    - DispatcherTimer _timer

    void DoTick()
    # {abstract} void Tick()
    + void Start()
    + void Stop()
}

class VirtualFunctionBus {
    - SystemComponent[] components
    - IReadOnlyDummyPacket DummyPacket
    + int getIReadOnlyDummyPacket()
    + void setIReadOnlyDummyPacket()
    + void registerComponent(SystemComponent component)
}

abstract class SystemComponent {
    # VirtualFunctionBus virtualFunctionBus
    # SystemComponent(VirtualFunctionBus virtualFunctionBus)
    + {abstract} void Process()
}

class DummySensor {
   - DummyPacket dummyPacket
}

class DummyPacket {
    - int distanceX
    - int distanceY
    + void setDistanceX()
    + int getDistanceX()
    + void setDistanceY()
    + int getDistanceY()
}

interface IReadOnlyDummyPacket {
    + int getDistanceX()
    + int getDistanceY()
}

DummySensor <|-- SystemComponent
DummySensor *-- DummyPacket
DummyPacket <-- IReadOnlyDummyPacket

VirtualFunctionBus <|-- GameBase
VirtualFunctionBus *-- "many" SystemComponent
VirtualFunctionBus *-- "1" IReadOnlyDummyPacket

header
DummySensor class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/dummy_sensor_class.svg" alt="" /></p>
<!--
```plantuml
@startuml
    interface ReactiveObject {
    }
    note right: This is required to update the View in the MVVM model.\nRaiseAndSetIfChanged() method must be used in the setters.

    class World << (S, #FF7700) Singleton >> {
        - int width
        - int height
        - WorldObject[] worldObjects
        - AutomatedCar controlledCar
        + int getWidth()
        + void setWidth()
        + int getHeight()
        + void setHeight()
        + void addObject()
        + AutomatedCar getControlledCar()
        + void setControlledCar()
    }

    abstract class WorldObject {
        - int x
        - int y
        - int zIndex
        - string filename
        + int getX()
        + void setX()
        + int getY()
        + void setY()
        + string getFilename()
        + void setFilename()
    }

    class Car {
        - int speed
        + int getSpeed()
        + void setSpeed()
    }

    class AutomatedCar {
        - VirtualFunctionBus virtualFunctionBus
        - DummySensor dummySensor
        + VirtualFunctionBus getVirtualFunctionBus()
        + void Start()
        + void Stop()
    }

    AutomatedCar <|-- Car
    Car <|-- WorldObject
    WorldObject <|-- ReactiveObject
    World *-- "many" WorldObject

header
AutomatedCar class diagram
endheader
@enduml
```
-->
<p><img src="plantuml/automatedcar_class.svg" alt="" /></p>
<h2 id="megjelenítés"><a class="header" href="#megjelenítés">Megjelenítés</a></h2>
<p>Az elkészítendő szoftver felhasználói felületének az alábbi vázlat felépítését kell követnie.</p>
<p><img src="images/gui_plan.png" alt="gui plan" /></p>
<p>A programablak bal oldalán a virtuális világ egy szeletét látjuk ezért felel a vizualizációs modul. A megjelenítés középpontja az mindenkor vezérelt autó (egocar). A világ minden eleméhez tartozik egy képfájl, ezen elemek megfelelő transzformációk (forgatás, skálázás) végrehajtása után kirajzolásra kerülne a CourseDisplayre.</p>
<p>Továbbá erre a részre kerülnek kirajzolásra a debuggoláshoz és teszteléshez használandó segédobjektumok opcionálisan bekapcsolható megjelenítése. Ide tartozik a szenzorok látómezeje, a világobjektumok „poligon váza”, valamint utóbbiak eseményre történő kiemelésének lehetősége.</p>
<p>A jobb oldalon a műszerfal található. A műszerfalon nincsenek vezérlőelemek, csak megjelenítés. Az összes kapcsoló a billentyűzettel állítható, a grafikus elemeknek nem kell pl. egérrel kapcsolhatónak lenniük.</p>
<p>A fordulatszám és a sebesség legyen egy analóg órával reprezentálva; a kormány elforgatás, a gáz- és fékpedál állása progressbar-okkal szemléltethető. Az irányjelző visszajelzője és a vezetéstámogató funkciók visszajelzői lámpaszerűek, a sebességváltó állása, és a debug értékek pl. kocsi pozíciója (x, y koordináta) lehet szöveges.
A buszon közölt „utoljára látott tábla” képét ki kell tudni rajzolni (a képek rendelkezésre állnak). Legyen elkülönítve a nincs tábla eset is.</p>
<p>A megjelenítéshez tetszőleges grafikus keretrendszer választható, alább a skeleton két változatban kerül bemutatásra.</p>
<h2 id="wpf-alapú-megjelenítés"><a class="header" href="#wpf-alapú-megjelenítés">WPF alapú megjelenítés</a></h2>
<p>Az ismert WPF alapú implementáció, amely egyenértékű a később taglalt Avalonia alapú megoldással. Mindkettő XAML alapú, MVVM modellű keretrendszer, előbbi Windows-os, utóbbi platform független.</p>
<p>A főablak két UserControlt tartalmaz, az egyik a CourseDisplay, a másik a Dashboard, azért lettek szétválasztva, hogy a két komponensen dolgozó csapatoknak ne kelljen egymás munkájába nyúlkálniuk.</p>
<p>Például, alább látható a műszerfal, amely egy <em>AutomatedCar</em> objektum megjelenítését végzi. Egészen pontosan a <em>World</em>-ben tárolt <code>controlledCar</code> objektumét. A <code>ControlledCar</code> tulajdonság egy referencia az éppen vezérelt autóra (elvben lehetne a világban több <code>AutomatedCar</code> példány és ezek között váltogathatnánk is. Ilyen esetben a <code>ControlledCar</code> mindeg az aktuálisra mutat, amelyet meg akarunk jeleníteni). A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name=&quot;Dashboard&quot; Content=&quot;{Binding World.ControlledCar, Mode=OneWay}&quot; &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3 id="coursedisplay"><a class="header" href="#coursedisplay">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel akár befolyásolni lehet a rajzolást (transzformálás).</p>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl Name=&quot;CourseDisplay&quot;
    ItemsSource=&quot;{Binding WorldObjects, Mode=OneWay}&quot;
    Width=&quot;{Binding Width, Mode=OneWay}&quot;
    Height=&quot;{Binding Height, Mode=OneWay}&quot;
    HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot;
    &gt;

     &lt;ItemsControl.ItemContainerStyle&gt;
        &lt;Style TargetType=&quot;ContentPresenter&quot;&gt;
            &lt;Setter Property=&quot;Canvas.Left&quot; Value=&quot;{Binding X}&quot;/&gt;
            &lt;Setter Property=&quot;Canvas.Top&quot; Value=&quot;{Binding Y}&quot;/&gt;
            &lt;Setter Property=&quot;Canvas.ZIndex&quot; Value=&quot;{Binding ZIndex}&quot;/&gt;
        &lt;/Style&gt;
    &lt;/ItemsControl.ItemContainerStyle&gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas /&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.Resources&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:Circle}&quot;&gt;
            &lt;Canvas&gt;
                &lt;Ellipse Fill=&quot;black&quot; Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot; Panel.ZIndex=&quot;10&quot;/&gt;
            &lt;/Canvas&gt;
        &lt;/DataTemplate&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
            &lt;Canvas&gt;
                &lt;Image Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot;
                    Source=&quot;{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}&quot;/&gt;
                &lt;Polyline Stroke=&quot;red&quot; Points=&quot;{Binding Geometry.Points, Mode=OneWay}&quot; /&gt;
            &lt;/Canvas&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.Resources&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A skeletonban esetben az objektum nem a képet tárolja, hanem a képfájl nevét (<code>Filename</code>, ez van a Source-hoz kötve), a fájlnévből pedig egy konverter segítségével kap a megjelenítés képet.</p>
<p>Ráadásul nem is tölti be minden esetben a képfájlokat, hanem gyorsító-tárazza azokat fájlnév alapján egy <code>Dictionary</code> segítségével. A <code>WorldObjectTransformer</code> singleton, hogy ez a mechanizmus megfelelően működhessen.</p>
<pre><code class="language-csharp">public class WorldObjectTransformer : IValueConverter
{
    private static Dictionary&lt;string, BitmapImage&gt; cache = new Dictionary&lt;string, BitmapImage&gt;();

    public static WorldObjectTransformer Instance { get; } = new WorldObjectTransformer();

    static BitmapImage GetCachedImage(string filename)
    {
        if (!cache.ContainsKey(filename))
        {
            var image = new BitmapImage(new Uri($&quot;src/AutomatedCar/Assets/WorldObjects/{filename}&quot;, UriKind.Relative));
            image.Freeze();
            cache.Add(filename, image);
        }
        return cache[filename];
    }

    public object Convert(object value, Type targetType, object parameter, CultureInfo culture) =&gt;
        GetCachedImage((string)value);
}
</code></pre>
<p>Megfigyelhető továbbá, hogy az AutomatedCar template esetében nem csak a kép van kirajzolva, hanem egy poligon ez, ez az objektum poligon váza, amelyet pl. ütközésekhez kell majd felhasználni. Előbb a kép, majd rá a polyline kerül kirajzolásra. Az ilyen poligonok megjelenítése debug funkciókét a megjelenítés feladata. A rajzolás pedig egy logikai értékhez kapcsolható...</p>
<h4 id="pozicionálás"><a class="header" href="#pozicionálás">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példán, hogy a <code>ItemsControl.ItemContainerStyle</code> rendelkezik az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az ItemsControl elemei (a WorldObject-ek) <em>X</em>, <em>Y</em> és <em>ZIndex</em> tulajdonságához van kötve a <code>ContentPresenter</code> <em>Canvas</em> <em>Left</em>, <em>Top</em> és <em>ZIndex</em> attribútuma.</p>
<p>Az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>
<h2 id="avalonia-alapú-megjelenítés"><a class="header" href="#avalonia-alapú-megjelenítés">Avalonia alapú megjelenítés</a></h2>
<p>Az <a href="http://avaloniaui.net/"><em>Avalonia</em> keretrendszer</a> által is használt <a href="http://avaloniaui.net/docs/quickstart/mvvm">MVVM modell</a>ben az objektumokhoz tartozik egy definiált a megjelenítés.</p>
<p><img src="http://avaloniaui.net/docs/quickstart/images/mvvm.png" alt="" /></p>
<p>Jelen esetben például a műszerfal egy <em>AutomatedCar</em> objektum megjelenítése. Egészen pontosan a <em>World</em>-ben tárolt <code>controlledCar</code> objektumé. A <em>DashboardView</em> a <em>DashboardViewModel</em>-en keresztül a <code>controlledCar</code>-hoz van kötve.</p>
<pre><code class="language-xml">&lt;ContentControl Name=&quot;Dashboard&quot; Content=&quot;{Binding World.ControlledCar, Mode=OneWay}&quot; &gt;
    &lt;ContentControl.ContentTemplate&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
            &lt;StackPanel&gt;
                ...
            &lt;/StackPanel&gt;
        &lt;/DataTemplate&gt;
    &lt;/ContentControl.ContentTemplate&gt;
&lt;/ContentControl&gt;
</code></pre>
<p>A példakód ezt biztosítja, a feladat a konkrét visszajelzőkhöz megfelelő felületi elemek definiálása.</p>
<h3 id="coursedisplay-1"><a class="header" href="#coursedisplay-1">CourseDisplay</a></h3>
<p>A teljes CourseDisplay lényegében egy <em>ItemsControl</em>, amely a világ <code>WorldObjects</code> tulajdonságához van kötve. Ezen belül található egy <em>Canvas</em>, amire a rajzolás történik, valamint egy <em>DataTemplate</em>, amely azt írja le, hogy egy <em>WorldObject</em> típusú objektumok hogyan kell kezelni. A világelemhez tartozó képet kell kirajzolni, így tartalmaz egy <em>Image</em>-et, amelynek forrása a <em>WorldObject</em> <code>Filename</code> tulajdonsága. A <em>Converter</em> attribútumon keresztül meg lehet hívni egy függvényt, amellyel befolyásolni lehet a rajzolást (transzformálás).</p>
<pre><code class="language-xml">&lt;ItemsControl Name=&quot;CourseDisplay&quot;
    DataContext=&quot;{Binding World, Mode=OneWay}&quot;
    Items=&quot;{Binding WorldObjects, Mode=OneWay}&quot;
    Width=&quot;{Binding Width, Mode=OneWay}&quot;
    Height=&quot;{Binding Height, Mode=OneWay}&quot;
    HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot;
    &gt;

    &lt;ItemsControl.ItemsPanel&gt;
        &lt;ItemsPanelTemplate&gt;
            &lt;Canvas/&gt;
        &lt;/ItemsPanelTemplate&gt;
    &lt;/ItemsControl.ItemsPanel&gt;

    &lt;ItemsControl.DataTemplates&gt;
        &lt;DataTemplate DataType=&quot;{x:Type models:WorldObject}&quot;&gt;
            &lt;Image Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot;
                Source=&quot;{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}&quot;/&gt;
        &lt;/DataTemplate&gt;
    &lt;/ItemsControl.DataTemplates&gt;
&lt;/ItemsControl&gt;
</code></pre>
<p>A <em>WorldObject</em> -az alkalmazás szempontjából- a világ minden elemének őse, de ennél specializáltabban is lehet definiálni <em>template</em>-eket. Az alábbi kódrészlet szétbontja <em>Circle</em> és <em>AutomatedCar</em> típusokra, előbbihez nem is képet tölt be, hanem közvetlenül rajzol a <em>Canvas</em>-re. Az utóbbi esetben egyrészt a fentivel megegyező módon betölt egy képet, valamit arra kirajzol egy poligont (ez a debug funkcióknál kell majd).</p>
<pre><code class="language-xml">&lt;ItemsControl.DataTemplates&gt;
    &lt;DataTemplate DataType=&quot;{x:Type models:Circle}&quot;&gt;
        &lt;Canvas&gt;
            &lt;Ellipse Fill=&quot;black&quot; Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot; ZIndex=&quot;10&quot;/&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
    &lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
        &lt;Canvas&gt;
            &lt;Image Width=&quot;{Binding Width}&quot; Height=&quot;{Binding Height}&quot;
                Source=&quot;{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}&quot;/&gt;
            &lt;Polyline Stroke=&quot;{Binding Brush, Mode=OneWay}&quot; Points=&quot;{Binding Geometry.Points, Mode=OneWay}&quot; /&gt;
        &lt;/Canvas&gt;
    &lt;/DataTemplate&gt;
&lt;/ItemsControl.DataTemplates&gt;
</code></pre>
<h4 id="pozicionálás-1"><a class="header" href="#pozicionálás-1">Pozicionálás</a></h4>
<p>Megfigyelhető, hogy  a fenti példák nem rendelkeznek az objektumok pozíciójáról. Ezt CSS-szerűen működő stílusokkal lehet megadni. Az alábbi példa beszínezi zöldre a <em>CourseDisplay</em>-t, valamint a <em>WorldObject</em>-ek <em>Left</em> és <em>Top</em> értékeit beállítja a <em>WorldObject</em> X és Y értének megfelelően.</p>
<pre><code class="language-xml">&lt;UserControl.Styles&gt;
    &lt;Style Selector=&quot;ItemsControl#CourseDisplay&quot;&gt;
        &lt;Setter Property=&quot;Background&quot; Value=&quot;#97D1A2&quot;/&gt;
    &lt;/Style&gt;
    &lt;Style Selector=&quot;ItemsControl#CourseDisplay &gt; ContentPresenter&quot;&gt;
        &lt;Setter Property=&quot;Canvas.Left&quot; Value=&quot;{Binding X, Mode=OneWay}&quot;/&gt;
        &lt;Setter Property=&quot;Canvas.Top&quot; Value=&quot;{Binding Y, Mode=OneWay}&quot;/&gt;
        &lt;Setter Property=&quot;ZIndex&quot; Value=&quot;{Binding ZIndex, Mode=OneWay}&quot;/&gt;
    &lt;/Style&gt;
&lt;/UserControl.Styles&gt;
</code></pre>
<p>Az utóbbi verziót használva az alábbi ábrán látható a futó alkalmazás: bal oldalt a kezdetleges CourseDisplay, jobb oldalt a kezdetleges Dashboard. Az autó az <code>(50, 50)</code> pozícióba van kirajzolva, a kör a <code>(400, 200)</code> koordinátákra (bal felső sarokkal értendő) ezek különbségét pedig kiszámolta a <em>DummySensor</em> és leolvasható a műszerfalról.</p>
<p><img src="images/avalonia_skeleton.png" alt="" /></p>
<h4 id="forgatás"><a class="header" href="#forgatás">Forgatás</a></h4>
<p>Az autó forgatása is a pozicionáláshoz hasonló elven történik. Az alábbi példában közvetlenül az egyes elem Canvas-ához csatoljuk a transzformációs utasításokat. Ez azzal is jár, hogy egyszerre lehet transzformálni a képet és a poligont is. Több transzformáció esetén fontos a <code>TransformGroup</code> használata. Például forgatás (szögben) az elem egy változójához kötve. Valamint egy X,Y eltolás az előbbi példában.</p>
<pre><code class="language-xml">&lt;DataTemplate DataType=&quot;{x:Type models:AutomatedCar}&quot;&gt;
    &lt;Canvas&gt;
        &lt;Canvas.RenderTransform&gt;
            &lt;TransformGroup&gt;
                &lt;RotateTransform Angle=&quot;{Binding Angle}&quot; /&gt;
                &lt;TranslateTransform  X=&quot;54&quot; /&gt;
                &lt;TranslateTransform  Y=&quot;120&quot; /&gt;
            &lt;/TransformGroup&gt;
        &lt;/Canvas.RenderTransform&gt;
        &lt;Image Source=&quot;{Binding Filename, Converter={x:Static visualization:WorldObjectTransformer.Instance}}&quot;/&gt;
        &lt;Polyline Stroke=&quot;{Binding Brush, Mode=OneWay}&quot; Points=&quot;{Binding Geometry.Points, Mode=OneWay}&quot; /&gt;
    &lt;/Canvas&gt;
&lt;/DataTemplate&gt;
</code></pre>
<p><img src="images/rotate.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="context-cards.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="d3.5.16.0.js"></script>
        <script type="text/javascript" src="markmap-lib.transform.min.js"></script>
        <script type="text/javascript" src="markmap-lib.view.min.js"></script>
        <script type="text/javascript" src="markmap-init.js"></script>
        <script type="text/javascript" src="quizdown/quizdown.js"></script>
        <script type="text/javascript" src="quizdown/quizdown-init.js"></script>
    </body>
</html>
